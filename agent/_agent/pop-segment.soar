#### apply pop-segment on the conversation-stack

sp {topstate*propose*pop-segment*clear-stack
   (state <s> ^topstate <s>
              ^interaction.stack.segment <seg>
              ^clear-interaction-stack true)
-->
   (<s> ^operator <o> + =)
   (<o> ^name pop-segment
        ^segment <seg>)
}

sp {topstate*propose*pop-segment
   (state <s> ^topstate <s>
              ^interaction <int>)
   (<int> ^status.performed <performed>
          ^stack.segment <seg>)
   (<seg> ^purpose.satisfaction <sat>)
   (<sat> ^<event> <sat-event>)
   (<sat-event> ^type <event-type>)
   (<performed> ^<event> <status-event>)
   (<status-event> ^type <event-type>)
   # Everything listed in the satisfaction is on the status
   -{(<sat-event> ^{<att> <> info} <val>)
     (<status-event> -^<att> <val>)}
-->
   (<s> ^operator <o> + =)
   (<o> ^name pop-segment
        ^segment <seg>
        ^performed <performed>)
}

sp {topstate*apply*pop-segment
   (state <s> ^topstate <s>
              ^operator <o>
              ^interaction.stack <stack>)
   (<o> ^name pop-segment
        ^segment <top-seg>)
   (<stack> ^segment <top-seg>)
   (<top-seg> ^next <next-seg>)
-->
   (<stack> ^segment <top-seg> -
            ^segment <next-seg>)
   (<next-seg> ^prev <top-seg> -)
}

# If we're clearing the stack and try to remove the bottom
#    remove the clear-interaction-stack flag
sp {topstate*apply*pop-segment*pop*bottom-seg
   (state <s> ^topstate <s>
              ^operator <o>
              ^clear-interaction-stack true)
   (<o> ^name pop-segment
        ^segment.id 0)
-->
   (<s> ^clear-interaction-stack true -)
}

sp {topstate*apply*pop-segment*clear*performed
   (state <s> ^topstate <s>
              ^operator <o>
              ^interaction.status <status>)
   (<o> ^name pop-segment
        ^performed <perf>)
   (<status> ^performed <perf>)
-->
   (<status> ^performed <perf> -)
}


### terminate an open segment on the interaction stack if the purpose of the segment is satisfied



### the segment was originated by the instructor and an action-event/learning-event was expected from the agent

# AM: Now there is an event substrcture that must be fully satisfied in the performed structure
#sp {propose*pop-segment*satisfaction*performed
#   (state <s> ^interaction.stack.segment <segment>
#   	      	  ^status.performed <performed>)
#   (<segment> ^purpose.satisfaction <sat>)
#   (<sat> ^<event> <sat-event>)
#   (<sat-event> ^type <event-type>)
#   (<performed> ^<event> <status-event>)
#   (<status-event> ^type <event-type>)
#   # Everything listed in the satisfaction is on the status
#   -{(<sat-event> ^{<att> <> info} <val>)
#     (<status-event> -^<att> <val>)}
#-->
#   (<s> ^operator <op> +)
#   (<op> ^name pop-segment
#   	 ^segment <segment>
#	 ^category interaction-stack)
#}

# XXX: Is this needed?
# AM: This rule is similar to the one above, if the next segment is also satisfied
#		The operator is marked so that the status sticks around
#sp {elaborate*pop-segment*next-is-satisfied
#   (state <s> ^interaction.stack.segment.next <next>
#   	      	  ^status.performed <performed>
#             ^operator <o> +)
#   (<next> ^purpose.satisfaction <sat>)
#   # The status and satisfaction match on both event and type
#   (<sat> ^<event> <sat-event>)
#   (<sat-event> ^type <event-type>)
#   (<performed> ^<event> <status-event>)
#   (<status-event> ^type <event-type>)
#   # Everything listed in the satisfaction is on the status
#   -{(<sat-event> ^{<att> <> info} <val>)
#     (<status-event> -^<att> <val>)}
#	(<o> ^name pop-segment)
#-->
#   (<o> ^next-is-satisfied true)
#}