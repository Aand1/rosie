# Special rules for the selection space during retrospective learning


#retrospective-learning
#  state-no-change [learn-proposal-rule]
#    op-no-change [composite-action]

sp {action*composite-action*learning*retrospective*best*preference*subaction
   (state <s> ^superstate.name learn-proposal-rule
              ^operator <o> +
              ^subactions.next.action-handle <handle>)
   (<o> ^action-handle { <handle> << recall1 remember1 >> })
-->
   (<s> ^operator <o> >)
}

sp {action*compsoite-action*learning*retrospective*advance*subaction*applied
   (state <s> ^superstate.name learn-proposal-rule
              ^operator <o>
              ^subactions <subs>)
   (<o> ^action-handle { <handle> << recall1 remember1 >> })
   (<subs> ^next <cur>)
   (<cur> ^action-handle <handle>
          ^next <next>)
-->
   (<subs> ^next <cur> -
           ^next <next>)
}
       

sp {action*composite-action*learning*retrospective*elaborate*problem-space*subactions*copy-type
   (state <s> ^superstate.name learn-proposal-rule
              ^problem-space <ps>)
   (<ps> ^name action
         ^learning.type retrospective)
-->
   (<ps> ^subactions.copy-type shallow)
}

sp {action*composite-action*learning*retrospective*elaborate*desired*if*none
   (state <s> ^superstate.name learn-proposal-rule
              ^problem-space.name action
              ^problem-space.learning.type retrospective
             -^desired.predicate)
-->
   (<s> ^desired <des>)
}

sp {action*composite-action*learning*retrospective*elaborate*desired*satisfied*superstate
   (state <s> ^superstate.name learn-proposal-rule
              ^problem-space.name action
              ^problem-space.learning.type retrospective
              ^desired.satisfied true
              ^superstate <ss>)
-->
   (<ss> ^desired.satisfied true)
}

#retrospective-learning
#  state-no-change [learn-proposal-rule]
#    op-no-change [composite-action]
#      operator-tie [selection]

sp {action*selection*learning*retrospective*elaborate*problem-space*subactions*copy-type
   (state <s> ^name selection
              ^problem-space <ps>)
   (<ps> ^name action
         ^learning.type retrospective)
-->
   (<ps> ^subactions.copy-type shallow)
}

sp {action*selection*learning*retrospective*elaborate*learning*use*chunking
   (state <s> ^name selection
              ^problem-space <ps>)
   (<ps> ^name action
         ^learning <learn>)
   (<learn> ^type retrospective)
-->
   (<learn> ^use chunking)
}

sp {action*selection*learning*retrospective*elaborate*current-subaction
   (state <s> ^name selection
              ^problem-space.name action
              ^problem-space.learning.type retrospective
              ^subactions.next <sub>)
-->
   (<s> ^action-to-match <sub>)
}

#retrospective-learning
#  state-no-change [learn-proposal-rule]
#    op-no-change [composite-action]
#      operator-tie [selection]
#        op-no-change [evaluate-operator]

sp {action*evaluate-operator*learning*retrospective*elaborate*problem-space*subactions*copy-type
   (state <s> ^name evaluate-operator
              ^problem-space <ps>)
   (<ps> ^name action
         ^learning.type retrospective)
-->
   (<ps> ^subactions.copy-type deep)
}

sp {retrospective-learning*evaluate-operator*apply*action*advance*subaction
   (state <s> ^name evaluate-operator
              ^look-ahead-operator <o>
              ^operator <o>
              ^subactions <subs>)
   (<subs> ^next <cur>)
   (<cur> ^next <next>)
-->
   (<subs> ^next <cur> -
           ^next <next>)
}
