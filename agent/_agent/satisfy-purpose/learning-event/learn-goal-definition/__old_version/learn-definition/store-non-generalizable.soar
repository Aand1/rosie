## non-generalizable structure are integral to verb definition #################################################

sp {store*goal*definition*non-generalizable*elaborate
   (state <s> ^name learn-definition
   	      ^goal-id.<arg> <pred-def>
   	      ^goal.{<arg> << relation-predicate state-predicate >>} <pred>
	      ^pairing <p>)
   (<p> ^smem <pred-def>
   	^wmem <pred>)
 -{(<s> ^generalizable <gen>)
   (<gen> ^wme-id <obj>)}
   (<pred> ^<< p1 p2 relation >> <obj>)
-->
   (<s> ^non-generalizable <obj>)
}

sp {store*goal*definition*non-generalizable*elaborate*smem-object
   (state <s> ^name learn-definition
   	      ^non-generalizable <obj>
	      ^smem.command <scomm>)
-->
   (<s> ^smem-wmem <sw>)
   (<sw> ^wmem <obj>
   	 ^smem <sobj>)
   (<scomm> ^store <sobj>)
}

###############################################################################################################
## relation values are dependent on p1, p2
sp {store*general*goal*definition*1*no-generalization*relation
   (state <s> ^name learn-definition
   	      ^goal-id.relation-predicate <grel>
	      ^goal.relation-predicate <relp>
	      ^smem.command <scomm>
	      ^pairing <p>
	      ^smem-wmem <sw>)
   (<p> ^smem <grel>
   	^wmem <relp>)
  # -{(<s> ^generalizable <gen>)
  #   (<gen> ^wme-id <obj>)}
   (<sw> ^wmem <obj>)
   (<relp> ^relation <obj>)
   (<obj> ^smem-rep <sobj>)
-->
   (<grel> ^relation <nobj>)
   (<nobj> ^default <def>)
   (<def> ^value <sobj>
   	  ^p1 <p1obj>
	  ^p2 <p2obj>)
   (<scomm> ^store <grel> <nobj> <sobj> <def>)
   (<p> ^default <def>)
}

sp {store*goal-definition*other*object*attributes*relation
   (state <s> ^name learn-definition
   	      ^goal-id.relation-predicate <grel>
      	      ^goal.relation-predicate <relp>
	      ^pairing <pair>
	      ^smem.command <scomm>)
   (<pair> ^smem <grel>
   	   ^wmem <relp>
	   ^default <def>)
   (<grel> ^relation.default <def>)
   (<def> ^value <val>
   	  ^{<arg2> << p1 p2 >>} <sobj>)
   (<relp> ^<arg2>.property <prop>)
   (<prop> ^label <label>
   	   ^name {<name> <> heat <> door})
-->
   (<sobj> ^<name> <label>)
   (<scomm> ^store <sobj>)
}

#########################################################################################################################
## state values are dependent on p1
sp {store*general*goal*definition*1*no-generalization*state
   (state <s> ^name learn-definition
   	      ^goal-id.state-predicate <grel>
	      ^goal.state-predicate <relp>
	      ^smem.command <scomm>
	      ^pairing <p>)
   (<p> ^smem <grel>
   	^wmem <relp>)
   (<relp> ^state <label>)
-->
   (<grel> ^state <nobj>)
   (<nobj> ^default <def>)
   (<def> ^value <label>
   	  ^p1 <p1obj>)
   (<scomm> ^store <grel> <nobj> <def>)
}

sp {store*goal-definition*other*object*attributes*state
   (state <s> ^name learn-definition
   	      ^goal-id.state-predicate <grel>
      	      ^goal.state-predicate <relp>
	      ^pairing <pair>
	      ^smem.command <scomm>)
   (<pair> ^smem <grel>
   	   ^wmem <relp>)
   (<grel> ^state.default <def>)
   (<def> ^value <val>
   	  ^{<arg2> << p1 p2 >>} <sobj>)
   (<relp> ^<arg2>.property <prop>)
   (<prop> ^label <label>
   	   ^name {<name> <> heat <> door})
-->
   (<sobj> ^<name> <label>)
   (<scomm> ^store <sobj>)
}

##################################################################################################################
## p1, p2 values are dependent on action arguments arguments

sp {store*general*goal*definition*no-generalization*p1*p2
   (state <s> ^name learn-definition
   	      ^smem-wmem <sw>
	      -^goal.relation-predicate.relation <obj>
	      -^goal.state-predicate.state <obj>
	      ^indexed-action.{<rarg2> <> name} <any>
	      -^ignore-set.attribute <rarg2>
	      ^smem.command <scomm>)
   (<sw> ^wmem <obj>
   	 ^smem <sobj>)
-->
   (<sobj> ^default <def>)
   (<def> ^value <defobj>
   	  ^<rarg2> <pobj>)
   (<scomm> ^store <sobj> <def> <defobj> <pobj>)
}

sp {store*goal-definition*p1*p2*value*attributes
   (state <s> ^name learn-definition
   	      ^smem-wmem <sw>
	      -^goal.relation-predicate.relation <obj>
	      -^goal.state-predicate.state <obj>
	      ^smem.command <scomm>)   
   (<sw> ^wmem <obj>
   	 ^smem <sobj>)
   (<sobj> ^default.value <val>)
   (<obj> ^property <prop>)
   (<prop> ^label <label>
   	   ^name {<name> <> heat <> door})
-->
   (<val> ^<name> <label>)
   (<scomm> ^store <val>)
}

sp {store*goal-definition*p1*p2*action-argument*attributes
   (state <s> ^name learn-definition
   	      ^smem-wmem <sw>
	      ^indexed-action.{<rarg2> <> name} <any>
	      -^goal.relation-predicate.relation <obj>
	      -^goal.state-predicate.state <obj>
	      ^smem.command <scomm>)   
   (<sw> ^wmem <obj>
   	 ^smem <sobj>)
   (<sobj> ^default.<rarg2> <obj-arg>)
   (<any> ^property <prop>)
   (<prop> ^label <label>
   	   ^name {<name> <> heat <> door})
-->
   (<obj-arg> ^<name> <label>)
   (<scomm> ^store <obj-arg>)
}



sp {store*general*goal*definition*1*no-generalization*p1*p2*relation
   (state <s> ^name learn-definition
   	      ^goal-id.relation-predicate <grel>
	      ^goal.relation-predicate <relp>
	      ^smem.command <scomm>
	      ^pairing <p>
	      ^smem-wmem <sw>)
   (<p> ^smem <grel>
   	^wmem <relp>)
   (<sw> ^wmem <obj>
   	 ^smem <nobj>)
   (<relp> ^{<rarg> << p1 p2 >>} <obj>)
-->
   (<grel> ^<rarg> <nobj>)
   (<scomm> ^store <grel>)
}

sp {store*general*goal*definition*1*no-generalization*p1*state
   (state <s> ^name learn-definition
   	      ^goal-id.state-predicate <grel>
	      ^goal.state-predicate <relp>
	      ^smem.command <scomm>
	      ^pairing <p>
	      ^smem-wmem <sw>)
   (<p> ^smem <grel>
   	^wmem <relp>)
   (<sw> ^wmem <obj>
   	 ^smem <nobj>)
   (<relp> ^{<rarg> << p1 >>} <obj>)
-->
   (<grel> ^<rarg> <nobj>)
   (<scomm> ^store <grel>)
}



