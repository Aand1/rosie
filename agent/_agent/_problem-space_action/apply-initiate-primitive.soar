sp {action*apply*primitive*initiate-operator*create*local*current-action
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>)
   (<o> ^action-type primitive
        ^action-name <action-name>)
-->
   (<s> ^current-action-copy <ca>)
   (<ca> ^name <action-name>
         ^first-appearance true
         ^execution-operator (concat |execute-| <action-name>)
         ^arguments <args>)
}

sp {action*execute*apply*primitive*initiate-operator*copy*action-context*composte
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^action-context <action>
              ^current-action-copy <current-action>)
   (<o> ^action-type primitive
        ^action-name <action-name>)
   (<current-action> ^name <action-name>)
-->
   (<current-action> ^action-context <action>)
}

sp {action*apply*primitive*initiate-operator*mark*copied-arguments
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^current-action-copy <ca>)
   (<o> ^action-type primitive
        ^action-name <action-name>)
   (<ca> ^name <action-name>)
-->
   (<s> ^copied-arguments true)
}

sp {action*apply*primitive*initiate-operator*copy*object*arg
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^current-action-copy <ca>)
   (<o> ^action-type primitive
        ^action-name <action-name>
        ^<arg-name> <arg>)
   (<arg> ^arg-type object
           ^object <obj>)
   (<ca> ^name <action-name>
         ^arguments <args>)
-->
   (<args> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type object
               ^object <obj>)
}

sp {action*apply*primitive*initiate-operator*copy*concept*arg
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^current-action-copy <ca>)
   (<o> ^action-type primitive
        ^action-name <action-name>
        ^<arg-name> <arg>)
   (<arg> ^arg-type concept
           ^handle <concept>)
   (<ca> ^name <action-name>
         ^arguments <args>)
-->
   (<args> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type concept
               ^handle <concept>)
}

sp {action*apply*primitive*initiate-operator*copy*level2*args
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^current-action-copy <ca>)
   (<o> ^action-type primitive
        ^action-name <action-name>
        ^<arg-name> <arg>)
   (<arg> ^arg-type predicate
           ^handle <pred-handle>
           ^2 <pred-obj>)
   (<ca> ^name <action-name>
         ^arguments <args>)
-->
   (<args> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type predicate
              ^handle <pred-handle>
              ^2 <pred-obj>)
}

sp {action*apply*primitive*initiate-operator*copy*until*args
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^current-action-copy <ca>)
   (<o> ^action-type primitive
        ^action-name <action-name>
        ^until-clause <until>)
   (<ca> ^name <action-name>
         ^arguments <args>)
-->
   (<args> ^until-clause <until>)
}

sp {action*apply*primitive*initiate-operator*copy*current-action*top-state*segment
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^current-action-copy <ca>
              ^copied-arguments true
              ^top-state.interaction.stack.segment <seg>)
   (<o> ^action-type primitive
        ^action-name <action-name>)
   (<ca> ^name <action-name>)
-->
   (<seg> ^current-action <ca>)
}
