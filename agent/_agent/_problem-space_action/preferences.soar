sp {action*reject*non-matched*operators
   (state <s> ^problem-space.name action
              ^operator <o> +
              ^operator-matches.match-info <info>)
   (<info> ^operator <o>
           ^op-matched no)
-->
   (<s> ^operator <o> -)
}

sp {reject*wait*if*until-clause*satisfied
   (state <s> ^problem-space.name action
              ^operator <o> +)
   (<o> ^name op_wait1
        ^until-clause <until>)
   (<until> ^satisfied true)
-->
   (<s> ^operator <o> -)
}

sp {action*best*preference*evaluate-operator*matched
   (state <s> ^problem-space.name action
              ^operator-matches.match-info <info>
              ^operator <o> +)
   (<info> ^op-matched yes
           ^operator <op>)
   (<o> ^name evaluate-operator
        ^superoperator <op>)
-->
   (<s> ^operator <o> >)
}

sp {action*subaction*best*preference
   (state <s> ^problem-space.name action
             -^problem-space.learning.type retrospective
              ^operator <o> +)
   (<o> ^subaction-handle <sub-handle>
        ^perform once)
-->
   (<s> ^operator <o> > =)
}

sp {action*reject*operator*if*until-clause*is*satisfied*state
   (state <s> ^problem-space.name action
             -^name execute-action
              ^operator <o> +)
   (<o> ^<arg-name> <arg>)
   (<arg> ^arg-type until-clause
          ^predicate <pred>)
   (<pred> ^type state
           ^handle <pred-handle>
           ^property-handle <prop-handle>
           ^{1}.predicates <preds>)
   (<preds> ^<prop-handle> <pred-handle>)
-->
   (<s> ^operator <o> -)
}
   
sp {action*reject*operator*if*until-clause*is*satisfied*relation
   (state <s> ^problem-space.name action
             -^name execute-action
              ^operator <o> +
              ^world.predicates.predicate <ts-pred>)
   (<o> ^<arg-name> <arg>)
   (<arg> ^arg-type until-clause
          ^predicate <pred>)
   (<pred> ^type relation
           ^handle <pred-handle>
           ^1 <obj1>
           ^2 <obj2>)
   (<ts-pred> ^handle <pred-handle>
              ^instance <i>)
   (<i> ^1 <obj1> ^2 <obj2>)
-->
   (<s> ^operator <o> -)
}

sp {action*prefer*go-to*over*explore
   (state <s> ^current-action.execution-operator.action-handle fetch1
              ^current-action.execution-operator.arg2 <arg2>
              ^operator <o1> +
              ^operator <o2> +)
   (<o1> ^name op_go-to-location1)
   (<o2> ^name op_explore1)
-->
   (<s> ^operator <o1> > <o2>)
}
          
#
#sp {action*reject*remember*if*no*effect
#   (state <s> ^problem-space.name action
#              ^operator <o> +
#              ^world.objects.object { <obj> <> <obj2> })
#   (<o> ^name op_remember1
#        ^arg2.id <obj2>)
#   (<obj> ^predicates <p1>)
#   (<obj2> ^predicates <p2>)
#   -{(<p2> ^{ <att> << property category >> } <val>)
#     (<p1> -^<att> <val>)}
#-->
#   (<s> ^operator <o> -)
#}
#
#sp {action*reject*recall*if*exists
#   (state <s> ^problem-space.name action
#              ^operator <o> +
#              ^world.objects.object <obj>
#              ^world.predicates.predicate <pred>)
#   (<o> ^name op_recall1
#        ^arg1 <arg1>
#        ^arg2 <arg2>)
#   (<arg1> ^arg-type << object location >>
#           ^id.linked-to <obj1>)
#   (<arg2> ^arg-type predicate
#           ^arg-status abstract
#           ^handle <pred-handle>
#           ^{2}.predicates <abs-preds>)
#   (<pred> ^handle <pred-handle>
#           ^instance <i>)
#   (<i> ^1 <obj1> ^{2}.predicates <preds>)
#   -{(<abs-preds> ^<prop-name> <pred-name>)
#     (<preds> -^<prop-name> <pred-name>)}
#-->
#   (<s> ^operator <o> -)
#}
# 