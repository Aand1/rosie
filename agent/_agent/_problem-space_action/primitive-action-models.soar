##############################################
# pick-up

# Mark the object as grabbed
sp {action*apply*pickup*do*action-model
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
          ^operator <op>)
   (<op> ^name op_pick-up1
     ^arg1.id.predicates <preds>)
   (<preds> ^arm-status not-grabbed)
-->
   (<preds> ^arm-status grabbed
            ^arm-status not-grabbed -)
}

# Remove any in/on relations the object has
sp {action*apply*pickup*do*action-model*remove*in*on*relation
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
              ^operator <o>
              ^world.predicates.predicate <pred>)
   (<o> ^name op_pick-up1
        ^arg1.id <obj>)
   (<pred> ^handle << in1 on1 >>
           ^instance <i>)
   (<i> ^1 <obj> ^2 <loc>)
-->
   (<pred> ^instance <i> -)
}

##############################################
# put-down

# Mark the object as not-grabbed
sp {action*apply*putdown*do*action-model*arm-status
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
               ^operator <o>)
   (<o> ^name op_put-down1
        ^arg1.id.predicates <obj1-preds>)
   (<obj1-preds> ^arm-status grabbed)
-->
   (<obj1-preds> ^arm-status grabbed -)
   (<obj1-preds> ^arm-status not-grabbed)
}

# Add the expected relation from the arg2
sp {action*apply*putdown*do*action-model*on
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
               ^operator <o>
               ^world.predicates.predicate <pred>)
   (<o> ^name op_put-down1
        ^arg1.id <obj1>
        ^arg2.{2} <obj2>
        ^arg2.handle <pred-handle>)
   (<pred> ^handle <pred-handle>)
-->
   (<pred> ^instance <i>)
   (<i> ^1 <obj1> ^2 <obj2>)
}

# Add the default in relation if there is no arg2
sp {action*apply*put-down*do*action-model*add*in*relation
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
              ^operator <o>
              ^world.robot.current-location <loc>
              ^world.predicates.predicate <pred>)
   (<o> ^name op_put-down1
        ^arg1.id <obj>
       -^arg2)
   (<pred> ^handle in1)
   (<obj> ^predicates.arm-status grabbed)
-->
   (<pred> ^instance <i>)
   (<i> ^1 <obj> ^2 <loc>)
}

##############################################
# go-to-location

# Add the location as the current-location for the robot
#  And marks as visible
sp {action*apply*go-to-location*do*action-model*add*new*location
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
              ^operator <o>
              ^world.robot <robot>)
   (<o> ^name op_go-to-location1
        ^arg2.2 <new-loc>)
   (<new-loc> ^predicates <preds>)
-->
   (<robot> ^current-location <new-loc>)
   (<preds> ^visibility not-visible1 -
            ^visibility visible1)
}

# Remove the old current-location from the robot
#   And mark it as not visible
sp {action*apply*go-to-location*do*action-model*remove*old*location
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
              ^operator <o>
              ^world.robot <robot>)
   (<o> ^name op_go-to-location1
        ^arg2.2 <new-loc>)
   (<robot> ^current-location { <old-loc> <> <new-loc> })
   (<old-loc> ^predicates <preds>)
-->
   (<robot> ^current-location <old-loc> -)
   (<preds> ^visibility visible1 -
            ^visibility not-visible1)
}

# Any objects that are in the new location are marked as visible
sp {action*apply*go-to-location*do*action-model*mark*new*object*visible
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
              ^operator <o>
              ^world <world>)
   (<o> ^name op_go-to-location1
        ^arg2.2 <new-loc>)
   (<world> ^predicates.predicate <in-pred>
            ^objects.object <obj>)
   (<in-pred> ^handle in1
              ^instance <i>)
   (<i> ^1 <obj> ^2 <new-loc>)
   (<obj> ^predicates <preds>)
-->
   (<preds> ^visibility not-visible1 -
            ^visibility visible1)
}

# Any objects that are in the old location are marked as visible
sp {action*apply*go-to-location*do*action-model*mark*old*objects*not*visible
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
              ^operator <o>
              ^world <world>)
   (<o> ^name op_go-to-location1
        ^arg2.2 <new-loc>)
   (<world> ^predicates.predicate <in-pred>
            ^objects.object <obj>)
   (<in-pred> ^handle in1
              ^instance <i>)
   (<i> ^1 <obj> ^2 { <old-loc> <> <new-loc> })
   (<obj> ^predicates <preds>)
-->
   (<preds> ^visibility visible1 -
            ^visibility not-visible1)
}


           
##############################################
# open

# Change the door from closed to open
sp {action*apply*open*do*action-model
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
          ^operator <op>)
   (<op> ^name op_open1
     ^arg1.id.predicates <preds>)
   (<preds> ^door1 closed2)
-->
   (<preds> ^door1 closed2 -
            ^door1 open2)
}

##############################################
# close

# Change the door predicate from open to closed
sp {action*apply*close*do*action-model
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
          ^operator <op>)
   (<op> ^name op_close1
     ^arg1.id.predicates <preds>)
   (<preds> ^door1 open2)
-->
   (<preds> ^door1 open2 -
            ^door1 closed2)
}

##############################################
# turn-on

# Change the activation predicate from off to on
sp {action*apply*turn-on*do*action-model
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
          ^operator <op>)
   (<op> ^name op_turn-on1
     ^arg1.id.predicates <preds>)
   (<preds> ^activation1 off2)
-->
   (<preds> ^activation1 off2 -
            ^activation1 on2)
}

##############################################
# turn-off

# Change the activation predicate from on to off
sp {action*apply*turn-off*do*action-model
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
          ^operator <op>)
   (<op> ^name op_turn-off1
     ^arg1.id.predicates <preds>)
   (<preds> ^activation1 on2)
-->
   (<preds> ^activation1 on2 -
            ^activation1 off2)
}


##############################################
# remember

# Adds source on the 2nd argument
sp {action*apply*remember*do*action-model
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
          ^operator <op>)
   (<op> ^name op_remember1
         ^arg1.id <arg1>
         ^arg2.id.predicates.<att> <val>)
   (<arg1> ^predicates <preds>)
-->
   (<preds> ^<att> <val>)
}

#############################################
# action has until clause

sp {action*apply*wait*do*action-model*until-clause*state*predicate
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
              ^operator <op>
              ^world <world>)
   (<op> ^name <any>
         ^until-clause.predicate <pred>)
   (<pred> ^type state
           ^handle <pred-handle>
           ^property-handle <prop-handle>
           ^{1}.predicates <preds>)
-->
   (<preds> ^<prop-handle> <pred-handle>)
}

sp {action*apply*wait*do*action-model*until-clause*state*predicate*remove*others
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
              ^operator <op>
              ^world <world>)
   (<op> ^name <any>
         ^until-clause.predicate <pred>)
   (<pred> ^type state
           ^handle <pred-handle>
           ^property-handle <prop-handle>
           ^{1}.predicates <preds>)
   (<preds> ^<prop-handle> { <val> <> <pred-handle> })
-->
   (<preds> ^<prop-handle> <val> -)
}

sp {action*apply*wait*do*action-model*until-clause*relation*predicate
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
              ^operator <op>
              ^world.predicates.predicate <ts-pred>)
   (<op> ^name <any>
         ^until-clause.predicate <pred>)
   (<pred> ^type relation
           ^handle <pred-handle>
           ^1 <obj1>
           ^2 <obj2>)
   (<ts-pred> ^handle <pred-handle>)
-->
   (<ts-pred> ^instance <i>)
   (<i> ^1 <obj1> ^2 <obj2>)
}

##############################################
# wait

sp {action*apply*wait*do*action-model
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
              ^operator <op>
              ^world <world>)
   (<op> ^name op_wait1
         ^until-clause.predicate <pred>)
   (<world> ^predicates.predicate <on-pred>
            ^objects.object <steak>
            ^objects.object <stove>)
   (<on-pred> ^handle on1
              ^instance <i>)
   (<i> ^1 <steak> ^2 <stove>)
   (<steak> ^predicates <steak-preds>)
   (<steak-preds> ^shape steak1)
   (<stove> ^predicates <stove-preds>)
   (<stove-preds> ^name stove
                  ^door1 closed2
                  ^activation1 on2)
   (<pred> ^type state
           ^handle cooked1
           ^property-handle meat1
           ^1 <steak>)
-->
   (<steak-preds> ^meat1 raw1 -
                  ^meat1 cooked1)
}

#########################################3
# recall 

sp {action*apply*recall*do*action-model
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
          ^operator <op>
          ^world.predicates.predicate <pred>)
   (<op> ^name op_recall1
         ^arg1.id.linked-to <obj1>
         ^arg2 <arg2>)
   (<arg2> ^arg-type predicate
           ^handle <pred-handle>
           ^{2}.linked-to <obj2>)
   (<pred> ^handle <pred-handle>)
-->
   (<pred> ^instance <i>)
   (<i> ^1 <obj1> ^2 <obj2>)
}

sp {action*apply*recall*do*action-model*add*object*arg
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
          ^operator <op>
          ^world.objects <objs>
          ^world.predicates.predicate <pred>)
   (<op> ^name op_recall1
         ^<arg-name> <arg>)
   (<arg> ^arg-type object
          ^id <obj>)
-->
   (<objs> ^object <obj>)
}

#####################################################
# apply subaction you perform once

sp {action*apply*subaction*mark*performed
   (state <s> ^problem-space.name action
              ^problem-space.action.type simulate
              ^operator <o>
              ^action-operator <op>)
   (<o> ^subaction-handle <sub-handle>
        ^perform once)
-->
   (<op> ^performed <sub-handle>)
}
