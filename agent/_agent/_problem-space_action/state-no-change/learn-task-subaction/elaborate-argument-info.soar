sp {learn-task-subaction*elaborate*argument-info
   (state <s> ^name learn-task-subaction
              ^subaction.<arg-name> <arg>)
   (<arg> ^arg-type <arg-type>)
-->
   (<s> ^argument-info <info>)
   (<info> ^instance <arg>
           ^arg-name <arg-name>
           ^arg-type <arg-type>
           ^generalized <gen>)
   (<gen> ^arg-type <arg-type>)
}

sp {learn-task-subaction*elaborate*argument-info*generalized*imagined
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>)
   (<arg-info> ^instance.imagined true
               ^generalized <gen>)
-->
   (<gen> ^imagined true)
}

# Elaborate the id and arguments with matches to procedural structures

sp {learn-goal-defintion*elaborate*argument-info*generalized*id*level1*arg
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>
              ^action-context <action>
              ^action-id.procedural <proc>)
   (<arg-info> ^arg-type << object concept location >>
               ^instance.id <obj>
               ^generalized <gen>)
   (<action> ^<arg-name>.id <obj>)
   (<proc> ^<arg-name>.id <slot>)
-->
   (<gen> ^id <slot>)
   (<arg-info> ^matches-procedural id)
}

sp {learn-goal-defintion*elaborate*argument-info*generalized*id*level2*arg
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>
              ^action-context <action>
              ^action-id.procedural <proc>)
   (<arg-info> ^arg-type << object concept location >>
               ^instance.id <obj>
               ^generalized <gen>)
   (<action> ^<arg-name>.{2} <obj>)
   (<proc> ^<arg-name>.{2} <slot>)
-->
   (<gen> ^id <slot>)
   (<arg-info> ^matches-procedural id)
}

sp {learn-goal-defintion*elaborate*argument-info*generalized*predicate*id
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>
              ^action-context <action>
              ^action-id.procedural <proc>)
   (<arg-info> ^arg-type predicate
               ^instance.handle <pred-handle>
               ^generalized <gen>)
   (<action> ^<arg-name>.handle <pred-handle>)
   (<proc> ^<arg-name>.id <slot>)
-->
   (<gen> ^id <slot>)
   (<arg-info> ^matches-procedural id)
}

sp {learn-goal-defintion*elaborate*argument-info*generalized*predicate*obj*2*level1
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>
              ^action-context <action>
              ^action-id.procedural <proc>)
   (<arg-info> ^arg-type predicate
               ^instance.{2} <obj>
               ^generalized <gen>)
   (<action> ^<arg-name>.id <obj>)
   (<proc> ^<arg-name>.id <slot>)
-->
   (<gen> ^2 <slot>)
   (<arg-info> ^matches-procedural 2)
}

sp {learn-goal-defintion*elaborate*argument-info*generalized*predicate*obj*2*level2
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>
              ^action-context <action>
              ^action-id.procedural <proc>)
   (<arg-info> ^arg-type predicate
               ^instance.{2} <obj>
               ^generalized <gen>)
   (<action> ^<arg-name>.{2} <obj>)
   (<proc> ^<arg-name>.{2} <slot>)
-->
   (<gen> ^2 <slot>)
   (<arg-info> ^matches-procedural 2)
}

# Elaborate the generalized structure with new default slots
sp {learn-task-subaction*elaborate*argument-info*new*id*slot*default
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type <any>
              -^matches-procedural id
              -^instance.imagined true
               ^generalized <gen>)
-->
   (<gen> ^id <new-slot>)
   (<new-slot> ^default <def>)
}

sp {learn-task-subaction*elaborate*argument-info*new*2*slot*default
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type predicate
              -^matches-procedural 2
              -^instance.imagined true
               ^generalized <gen>)
-->
   (<gen> ^2 <new-slot>)
   (<new-slot> ^default <def>)
}

# Elaborate the generalized structure with new imagined slots
sp {learn-task-subaction*elaborate*argument-info*new*id*slot*imagined
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type <any>
              -^matches-procedural id
               ^instance.imagined true
               ^generalized <gen>)
-->
   (<gen> ^id <new-slot>)
   (<new-slot> ^imagined <img>)
}

sp {learn-task-subaction*elaborate*argument-info*new*2*slot*imagined
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type predicate
              -^matches-procedural 2
               ^instance.imagined true
               ^generalized <gen>)
-->
   (<gen> ^2 <new-slot>)
   (<new-slot> ^imagined <img>)
}

# Elaborate the id and arguments with default slot info
sp {learn-task-subaction*elaborate*argument-info*generalized*default*concept*handle
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type concept
               ^instance.handle <concept-handle>
               ^generalized.id.{ << default imagined >> } <def>)
-->
   (<def> ^argument-handle <pred-handle>)
}

sp {learn-task-subaction*elaborate*argument-info*generalized*default*predicate*handle
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type predicate
               ^instance.handle <pred-handle>
               ^generalized.id.{ << default imagined >> } <def>)
-->
   (<def> ^argument-handle <pred-handle>)
}

sp {learn-task-subaction*elaborate*argument-info*generalized*default*object*predicates
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type << object location >>
               ^instance.id.predicates <preds>
               ^generalized.id.{ << default imagined >> } <def>)
   (<preds> ^{ <prop-handle> << color shape size category name property >> } <pred-handle>)
-->
   (<def> ^<prop-handle> <pred-handle>)
}

sp {learn-task-subaction*elaborate*argument-info*generalized*default*object*2*predicates
   (state <s> ^name learn-task-subaction
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type predicate
               ^instance.{2}.predicates <preds>
               ^generalized.{2}.{ << default imagined >> } <def>)
   (<preds> ^{ <prop-handle> << color shape size category name property >> } <pred-handle>)
-->
   (<def> ^<prop-handle> <pred-handle>)
}

