sp {learn-subaction-proposal*elaborate*ground-argument*until-predicate*expand*state*predicate
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>)
   (<arg> ^arg-type until-predicate
          ^generalized-rep <until-pred>)
   (<until-pred> ^type state
                 ^id <pred-rep>
                 ^1 <obj-rep>)
-->
   (<arg> ^id <ground-pred>
          ^1 <ground-obj>)
   (<s> ^ground-argument <ground-pred> <ground-obj>)
   (<ground-pred> ^generalized-rep <pred-rep>
                  ^arg-type concept)
   (<ground-obj> ^generalized-rep <obj-rep>
                 ^arg-type object)
}

sp {learn-subaction-proposal*elaborate*ground-argument*until-predicate*expand*relation*predicate
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>)
   (<arg> ^arg-type until-predicate
          ^generalized-rep <until-pred>)
   (<until-pred> ^type relation
                 ^id <pred-rep>
                 ^1 <obj1-rep>
                 ^2 <obj2-rep>)
-->
   (<arg> ^id <ground-pred>
          ^1 <ground-obj1>
          ^2 <ground-obj2>)
   (<s> ^ground-argument <ground-pred> <ground-obj1> <ground-obj2>)
   (<ground-pred> ^generalized-rep <pred-rep>
                  ^arg-type predicate)
   (<ground-obj1> ^generalized-rep <obj1-rep>
                  ^arg-type object)
   (<ground-obj2> ^generalized-rep <obj2-rep>
                  ^arg-type object)
}


##### Try to match the argument against procedural slots #####
   
sp {learn-subaction-proposal*elaborate*ground-argument*matches*object*depth*1
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.id <obj>)
   (<arg> ^arg-type << object location >>
          ^generalized-rep <obj-slot>)
   (<parg> ^arg-type << object location >>
           ^id <obj-slot>)
-->
   (<arg> ^matches <obj>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*matches*object*depth*2
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.{2} <obj>)
   (<arg> ^arg-type << object location >>
          ^generalized-rep <obj-slot>)
   (<parg> ^arg-type predicate
           ^2 <obj-slot>)
-->
   (<arg> ^matches <obj>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*matches*concept
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.handle <concept-handle>)
   (<arg> ^arg-type concept
          ^generalized-rep <conc-slot>)
   (<parg> ^arg-type concept
           ^id <conc-slot>)
-->
   (<arg> ^matches <conc-handle>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*matches*predicate
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.handle <pred-handle>)
   (<arg> ^arg-type predicate
          ^generalized-rep <pred-slot>)
   (<parg> ^arg-type predicate
           ^id <pred-slot>)
-->
   (<arg> ^matches <pred-handle>)
}

##### Elaborate the default matches #######

sp {learn-subaction-proposal*elaborate*ground-argument*matches-default*concept
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>)
   (<arg> ^arg-type concept
          ^generalized-rep.default.predicate-handle <handle>)
-->
   (<arg> ^matches-default <handle>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*matches-default*predicate
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>)
   (<arg> ^arg-type predicate
          ^generalized-rep.default.predicate-handle <handle>)
-->
   (<arg> ^matches-default <handle>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*matches-default*matches*object*1*predicate
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep.default <def>)
   (<def> ^<prop1> <pred1>)
   -{(<def> ^{ <prop2> <> <prop1> })}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>)
-->
   (<arg> ^matches-default <obj>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*matches-default*matches*object*2*predicate
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>)
   -{(<def> ^{ <prop3> <> <prop1> <> <prop2> })}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>)
-->
   (<arg> ^matches-default <obj>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*matches-default*matches*object*3*predicate
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>)
   -{(<def> ^{ <prop4> <> <prop1> <> <prop2> <> <prop3>})}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>)
-->
   (<arg> ^matches-default <obj>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*matches-default*matches*object*4*predicate
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>)
   -{(<def> ^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4>})}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>)
-->
   (<arg> ^matches-default <obj>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*matches-default*matches*object*5*predicate
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>
          ^{<prop5> > <prop4>} <pred5>)
   -{(<def> ^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5>})}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>
            ^<prop5> <pred5>)
-->
   (<arg> ^matches-default <obj>)
}



#### Elaborate the instance #####

sp {learn-subaction-proposal*elaborate*ground-argument*instance*matches
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>)
   (<arg> ^matches <instance>)
-->
   (<arg> ^instance <instance>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*instance*imagined
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>)
   (<arg> -^matches
           ^matches-imagined <instance>)
-->
   (<arg> ^instance <instance>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*instance*default
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>)
   (<arg> -^matches
          -^matches-imagined
           ^matches-default <instance>)
-->
   (<arg> ^instance <instance>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*instance*state*until-predicate
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>)
   (<arg> ^arg-type until-predicate
          ^generalized-rep.type state
          ^id.instance <handle>
          ^{1}.instance <obj1>)
-->
   (<arg> ^instance <instance>)
   (<instance> ^type state ^handle <handle> ^1 <obj1>)
}

sp {learn-subaction-proposal*elaborate*ground-argument*instance*relation*until-predicate
   (state <s> ^name learn-subaction-proposal
              ^ground-argument <arg>)
   (<arg> ^arg-type until-predicate
          ^generalized-rep.type relation
          ^id.instance <handle>
          ^{1}.instance <obj1>
          ^{2}.instance <obj2>)
-->
   (<arg> ^instance <instance>)
   (<instance> ^type relation ^handle <handle> ^1 <obj1> ^2 <obj2>)
}
