sp {learn-subaction-proposal*propose*create-operator-argument
   (state <s> ^name learn-subaction-proposal
              ^subaction-id <sub>
              ^argument-map.argument <map-arg>)
   (<sub> ^<arg-name> <sub-arg>)
   (<sub-arg> ^arg-type <arg-type>)
   (<map-arg> ^source <sub-arg>
             -^created true)
-->
   (<s> ^operator <o> + =)
   (<o> ^name create-operator-argument
        ^arg-name <arg-name>
        ^argument <sub-arg>)
}

sp {learn-subaction-proposal*apply*create-operator-argument*level1
   (state <s> ^name learn-subaction-proposal
              ^operator <o>
              ^argument-match-info <info>
              ^subaction-operator <op>
              ^argument-map.argument <map-arg>)
   (<o> ^name create-operator-argument
        ^arg-name <arg-name>
        ^argument <sub-arg>)
   (<sub-arg> ^arg-type { <type> << object concept location >> }
              ^id <slot>)
   (<info> ^slot <slot>
           ^final-match <m>)
   (<map-arg> ^source <sub-arg>)
-->
   (<op> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type <type>
              ^id <m>)
   (<map-arg> ^created true)
}

sp {learn-subaction-proposal*apply*create-operator-argument*level2
   (state <s> ^name learn-subaction-proposal
              ^operator <o>
              ^argument-match-info <pred-info>
              ^argument-match-info <obj-info>
              ^subaction-operator <op>
              ^argument-map.argument <map-arg>)
   (<o> ^name create-operator-argument
        ^arg-name <arg-name>
        ^argument <sub-arg>)
   (<sub-arg> ^arg-type predicate
              ^id <pred-slot>
              ^2 <obj-slot>)
   (<pred-info> ^slot <pred-slot>
                ^final-match <pred-m>)
   (<obj-info> ^slot <obj-slot>
                ^final-match <obj-m>)
   (<map-arg> ^source <sub-arg>)
-->
   (<op> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type predicate
              ^id <pred-m>
              ^2 <obj-m>)
   (<map-arg> ^created true)
}
   