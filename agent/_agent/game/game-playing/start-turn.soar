sp {chunk-9*d3117*tie*1
    :chunk
    (state <s1> ^problemspace action ^name op_1 ^desired <d1>
          ^not-tracking <n1> ^object <p1> ^object <p2> ^operator <o1> +
          ^problem-space <p3>)
    (<d1> -^achieve-state <a1> ^track-relation <n1>)
    (<n1> ^p2 <p1> ^p1 <p2> ^relation <r1>)
    (<p1> ^focus constant5p2 ^focus op_1argument4)
    (<p2> ^focus op_1argument3)
    (<o1> ^argument1 <p2> ^name op_pick-up-object)
    (<p3> ^name op_1)
    -->
    (<s1> ^operator <o1> >)
}

sp {chunk-8*d3116*tie*1
    :chunk
    (state <s1> ^problemspace action ^name op_1 ^desired <d1>
          ^not-tracking <n1> ^grabbed <g1> ^object <g1> ^operator <o1> +
          ^problem-space <p3>)
    (<d1> -^achieve-state <a1> ^track-relation <n1>)
    (<n1> ^p2 <p1> ^p1 <p2> ^relation <r1>)
    (<p1> ^focus op_1argument4)
    (<p2> ^focus op_1argument3)
    (<g1> ^focus op_1argument3)
    (<o1> ^argument1 <g1> ^name op_put-down-object-location ^argument2 <a2>)
    (<p3> ^name op_1)
    (<a2> ^argument <a3> ^relation <r1>)
    (<a3> ^focus op_1argument4)
    -->
    (<s1> ^operator <o1> >)
}

sp {chunk-6*d3115*tie*3
    :chunk
    (state <s1> ^problemspace action ^name op_1 ^problem-space <p1>
          ^desired <d1> ^operator <o1> +)
    (<p1> ^name op_1)
    (<d1> ^track-relation <t1>)
    (<t1> ^p2 <p2> ^relation <r1>)
    (<p2> ^focus op_1argument4)
    (<o1> ^argument2 <a1>)
    (<a1> ^argument <a2>)
    (<a2> ^focus op_1argument4)
    -->
    (<a1> ^relation <r1> +)
}

sp {chunk-4*d3115*tie*1
    :chunk
    (state <s1> ^problemspace action ^name op_1 ^problem-space <p1>
          ^desired <d1> ^operator <o1> +)
    (<p1> ^name op_1)
    (<d1> ^track-relation <t1>)
    (<t1> ^p2 <p2> ^relation <r1>)
    (<p2> ^focus constant5p2)
    (<o1> ^argument2 <a1>)
    (<a1> ^argument <a2>)
    (<a2> ^focus constant5p2)
    -->
    (<a1> ^relation <r1> +)
}

#sp {chunk-3*d3114*tie*3
#    :chunk
#    (state <s1> ^problemspace action ^superstate <s2> ^operator <o1> +)
#    (<s2> ^relevant-segment-id 100101)
#    (<o1> ^argument2 <a1>)
#    (<a1> ^argument <a2>)
#    (<a2> ^id 3)
#    -->
#    (<a1> ^relation <r1> +)
#    (<r1> ^smem-rep @P2 +)
#}

sp {chunk-2*d3114*unknownimpasse*2
    :chunk
    (state <s1> ^problemspace action ^desired <d1> ^operator <o1> +)
    (<d1> ^track-relation <t1>)
    (<t1> ^p2 <p1> ^relation <r1>)
    (<p1> ^focus constant5p2)
    (<o1> ^argument2 <a1>)
    (<a1> ^argument <a2>)
    (<a2> ^focus constant5p2)
    -->
    (<a1> ^relation <r1> +)
}

sp {chunk-1*d3114*unknownimpasse*1
    :chunk
    (state <s1> ^problemspace action ^desired <d1> ^operator <o1> +)
    (<d1> ^track-relation <t1>)
    (<t1> ^p2 <p1> ^relation <r1>)
    (<p1> ^focus op_1argument4)
    (<o1> ^argument2 <a1>)
    (<a1> ^argument <a2>)
    (<a2> ^focus op_1argument4)
    -->
    (<a1> ^relation <r1> +)
}



##################################333
##########################################

sp {start-turn*propose*find-action
   (state <s> ^name start-turn
             -^action)
-->
   (<s> ^operator <o> + =)
   (<o> ^name find-action
        ^category svs) # for now determine better or new category)
}
#handle failed object/action look up
sp {start-turn*propose*do-action
   (state <s> ^name start-turn
              ^action <action>
              ^predicate <p>
             -^success
              ^obj1 <oa>
              ^obj2 <ob>)
-->
   (<s> ^operator <o> + =)
   (<o> ^name do-action
        ^category svs
        ^action <action>
        ^predicate <p>
        ^obj1 <oa>
        ^obj2 <ob>)
}

sp {do-action*propose*comprehend-action-command
   (state <s> ^name do-action
              ^action <action>
              ^obj1 <oa>
             -^found-op
              ^predicate <p>
              ^obj2 <ob>)
   (<action> ^verb <verb-word>)
-->
#   (interrupt)
   (<s> ^operator <o> + = )
   (<o> ^name comprehend-action-command ^parameter <pa> ^initialized true)
   (<pa> ^direct-object <do-param>
       ^pp-object <po-param>
       ^verb <verb-param>
       ^type action-command)
   (<do-param> ^type direct-object
               ^result <oa>)
   (<po-param> ^type pp-object
               ^result <res1>)
   (<res1> ^object <ob>)
   (<verb-param> ^type verb
                 ^lexical <verb-word>)
}

sp {do-action*apply*comprehend-action-command*hackforarg4
   (state <s> ^name do-action
              ^action <action>
              ^obj1 <oa>
              ^predicate <p>
              ^obj2 <ob>
              ^operator <o>)
   (<o> ^name comprehend-action-command 
        ^parameter <pa>)
   (<pa> ^result <op>)
   (<op> -^argument4 
          ^_metadata.map-id <mid>)
   (<mid> ^procedural.argument4 <n7>
          ^linguistic.pp-object.object <n3>)
-->
   (<s> ^found-op <op>)
   (<op> ^argument4 <arg4>)
   (<arg4> ^argument <ob>)
}


sp {do-action*apply*comprehend-action-command
   (state <s> ^name do-action
              ^action <action>
              ^obj1 <oa>
              ^predicate <p>
              ^obj2 <ob>
              ^operator <o>)
   (<o> ^name comprehend-action-command 
        ^parameter <pa>)
   (<pa> ^result <op>)
   (<op> ^argument4)
-->
   (<s> ^found-op <op>)
}


sp {do-action*store*topaction
   (state <s> ^name do-action
              ^action <action>
              ^obj1 <oa>
              ^topstate <ts>
              ^found-op <op>
              ^predicate <p1>
              ^obj2 <ob>)
-->
#   (interrupt)
   (<ts> ^action-todo <op>)
}
sp {do-action*propose*topstateaction
   (state <s> ^topstate <s>
              ^action-todo <op>)
-->
   (<s> ^operator <o> +)
   (<o> ^name action
        ^purpose <p>
        ^indexed-action <op>)
}
sp {do-action*apply*indicate-completed-action
   (state <s> ^name action
              ^topstate <ts>
              ^topstate.action-todo <op>
              ^operator.name indicate-completed-action)
-->
   (<ts> ^action-todo <op> -)
}

sp {do-action*apply*indicate-completed-action*remove-projection
   (state <s> ^name action
              ^operator.name indicate-completed-action
              ^topstate.svs.command <cmd>)
   (<cmd> ^project <P11>)
-->
   (<cmd> ^project <P11> -)
}


#sp {do-action*finish*operator
#   (state <s> ^name do-action
#              ^superstate <ss>
#              ^success <suc>)
#-->
#   (<ss> ^success true)
#}

sp {start-turn*propose*complete-turn
   (state <s> ^name start-turn
              ^completed-all-actions true)
 -->
   (<s> ^operator <o> +)
   (<o> ^name complete-turn
        ^category svs)
}
#sp {start-turn*propose*wait
#   (state <s> ^name complete-turn
#   	     -^operator.name wait)
# -->
#   (<s> ^operator <o> +)
#   (<o> ^name wait
#        ^category svs)
#}

##sp {start-turn*apply*complete-turn
##   (state <s> ^name start-turn
##              ^topstate.status <status>
##              ^action <a>
##             -^solved
##              ^operator <o>)
##   (<o> ^name complete-turn)
##-->
##   (interrupt)
##   
##   (<s> ^action <a> -)
##}
#
##sp {start-turn*apply*remove-stale-svs-extracts
##   (state <s> ^name start-turn
##              ^topstate.status <status>
##              ^action <a>
##             -^solved
##              ^topstate.svs.command <cmd>
##              ^operator <o>)
##   (<o> ^name complete-turn)
##   (<cmd> ^{<arg> << extract_once extract project >>} <E11>)
##   (<E11> ^a <N7> ^b <N8>)
##-->
##   (<cmd> ^<arg> <E11> -)
##}
##sp {start-turn*apply*remove-stale-svs-project
##   (state <s> ^name start-turn
##              ^topstate.status <status>
##              ^action <a>
##             -^solved
##              ^topstate.svs.command <cmd>
##              ^operator <o>)
##   (<o> ^name complete-turn)
##   (<cmd> ^project <E11>)
##-->
##   (<cmd> ^project <E11> -)
##}


#sp {start-turn*apply*complete-turn
#   (state <s> ^name start-turn
#              ^topstate.status <status>
#              ^topstate <ts>
#              ^action <a>
#             -^solved
#              ^topstate.self.action wait
#              ^topstate.self.prev-action drop
#              ^operator <o>)
#   (<o> ^name complete-turn)
#-->
#   (<status> ^performed.action-event.type turn) 
#   (<ts> ^instructor-message <msg>)
#   (<msg> ^type object-message
#          ^information.object.word turn)
#}

#sp {start-turn*apply*complete-turn
#   (state <s> ^name start-turn
#              ^topstate.interaction.status <status>
#              ^topstate <ts>
##              ^action <a>
#              ^obj1 <o1>
#              ^obj2 <o2>
#              ^success <suc>
#             -^solved
#              ^topstate.track-relation <tr>
##              ^topstate.self.action wait
##              ^topstate.self.prev-action drop
#              ^topstate.flound-action <fa>
#              ^operator <o>)
#   (<o> ^name complete-turn)
#   (<o1> ^focus <f1>)
#   (<o2> ^focus <f2>)
#   (<fa> ^obj1 <oa> ^obj2 <ob> ^dcount <dc> -^mark)
#  -{(<ts> ^flound-action <fa2>)
#    (<fa2> -^mark ^dcount < <dc>)}      
#-->
##   (interrupt)
#   (<s> ^action <a> -)
#   (<s> ^obj1 <o1> -)
#   (<s> ^obj2 <o2> -)
#   (<s> ^success <suc> -)
#   (<ts> ^track-relation <tr> -)
#   (<o1> ^focus <f1> -)
#   (<o2> ^focus <f2> -)
##   (<s> ^obj1 <oa>)
##   (<s> ^obj2 <ob>)
#}

sp {start-turn*apply*complete-turn*solved*did-all-actions
   (state <s> ^name start-turn
              ^topstate.interaction.status <status>
#              ^action <a>
#              ^topstate.flound-action <fa>
#              ^topstate.self.action wait
#              ^topstate.self.prev-action drop
              ^operator <o>)
#   (<fa> ^dcount <dc> ^mark)
#  -{(<ts> ^flound-action <fa2>)
#    (<fa2> ^dcount > <dc>)}    
   (<o> ^name complete-turn)
-->
#   (interrupt)
   (<status> ^performed.dialog-event.type turn) 
}

#sp {start-turn*apply*complete-turn*solved
#   (state <s> ^name start-turn
#              ^topstate.interaction.status <status>
#              ^action <a>
#              ^solved
##              ^topstate.self.action wait
##              ^topstate.self.prev-action drop
#              ^operator <o>)
#   (<o> ^name complete-turn)
#-->
#   (<status> ^performed.action-event.type turn) 
#}