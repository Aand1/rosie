###################################################################
#
# interpret-yes-no-message
#   Occurs when the intructor wishes to give additional information about an object
#   Construction: *-What-is-DP-QT 
#   	E.g. 'What is this?'
#
###################################################################

#######
# OPERATOR PROPOSAL
#######
sp {interpret-message*propose*interpret-yes-no-message
   (state <s> ^name interpret-message
              ^instructor-message <msg>)
   (<msg> ^message-type { << yes no >> <type> }
         -^interpreted true)
-->
   (<s> ^operator <o> +)
   (<o> ^name interpret-yes-no-message
        ^message <msg>
        ^message-type <type>)
}

#####
# OPERATOR APPLICATION
#####

# Don't even need to do any special processing, just create a response
sp {interpret-message*apply*interpret-yes-no-message*mark
   (state <s> ^name interpret-message
              ^top-state.current-action
              ^operator <o>)
   (<o> ^name interpret-yes-no-message
        ^message <msg>)
-->
   (<msg> ^interpreted true)
}

sp {interpret-message*apply*interpret-yes-no-message*yes*mark*received-yes*action
   (state <s> ^name interpret-message
              ^top-state.current-action <a>
              ^operator <o>)
   (<o> ^name interpret-yes-no-message
        ^message-type yes)
-->
   (<a> ^received-yes true)
}
    
sp {interpret-message*apply*interpret-yes-no-message*yes*mark*received-no*action
   (state <s> ^name interpret-message
              ^top-state.current-action <a>
              ^operator <o>)
   (<o> ^name interpret-yes-no-message
        ^message-type no)
-->
   (<a> ^received-no true)
}

sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-goal-initiate-state
   (state <s> ^name interpret-message
              ^top-state.dialog-context <dc>
              ^operator <o>)
   (<o> ^name interpret-yes-no-message
        ^message-type yes)
   (<dc> ^needs-setup true ^learning true)
-->
   (<s> ^new-segment-info <info>
        ^mark-interpreted <msg>)
   (<info> ^purpose <p>
           ^originator instructor)
   (<p> ^type learn-goal-initial-state
        ^parameters.message <msg>
        ^satisfaction <sat>)
   (<sat> ^learning-event.type game)
}
#started by naming, not describing
sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-goal
   (state <s> ^name interpret-message
              ^top-state <ts>
              ^operator <o>)
   (<ts> ^dialog-context <dc> ^interaction.changes <changes>)
   (<o> ^name interpret-yes-no-message
        ^message <msg>
        ^message-type yes)
   (<dc> ^needs-goal-setup <t> ^learning true -^parsed-goal)
-->
   (<msg> ^interpreted true)
   (<dc> ^needs-goal-setup <t> -)
   (<changes> ^outgoing-message <msg2>)
   (<msg2> ^type simple-message
              ^message-type describe-goal)
}
sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-failure
   (state <s> ^name interpret-message
              ^top-state <ts>
              ^operator <o>)
   (<ts> ^dialog-context <dc> ^interaction.changes <changes>)
   (<o> ^name interpret-yes-no-message
        ^message <msg>
        ^message-type yes)
   (<dc> ^needs-failure-setup <t> ^learning true -^parsed-failure)
-->
   (<msg> ^interpreted true)
   (<dc> ^needs-failure-setup <t> -)
   (<changes> ^outgoing-message <msg2>)
   (<msg2> ^type simple-message
              ^message-type describe-failure)
}

#started by describing
sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-goal*predescribed
   (state <s> ^name interpret-message
              ^top-state <ts>
              ^operator <o>)
   (<ts> ^dialog-context <dc>)
   (<o> ^name interpret-yes-no-message
        ^message <msg>
        ^message-type yes)
   (<dc> ^needs-goal-setup <t> ^learning true ^parsed-goal <msg2>)# -^stored-sentence <se>)
-->
   (<msg> ^interpreted true)
#   (<ts> ^stored-sentence <se>)
 #  (<dc> ^needs-goal-setup <t> -)
   (<s> ^new-segment-info <info>)
   (<info> ^purpose <p>
           ^originator instructor)
   (<p> ^type learn-goal-predicate
        ^parameters.message <msg2>
        ^satisfaction <sat>)
   (<sat> ^learning-event.type game)
}

#sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-goal*predescribed
#   (state <s> ^name interpret-message
#              ^top-state <ts>
#              ^operator <o>)
#   (<ts> ^dialog-context <dc>)
#   (<o> ^name interpret-yes-no-message
#        ^message <msg>
#        ^message-type yes)
#   (<dc> ^needs-goal-setup <t> ^learning true ^parsed-goal <msg2> ^stored-sentence <se>)
#-->
#   (<msg> ^interpreted true)
##   (<ts> ^stored-sentence <se>)
# #  (<dc> ^needs-goal-setup <t> -)
#   (<s> ^new-segment-info <info>)
#   (<info> ^purpose <p>
#           ^originator instructor)
#   (<p> ^type learn-goal-predicate
#        ^parameters.message <msg2>
#        ^satisfaction <sat>)
#   (<sat> ^learning-event.type game)
#}

sp {interpret-message*apply*interpret-yes-no-message*yes**create*segment*learn-failure*predescribed
   (state <s> ^name interpret-message
              ^top-state <ts>
              ^operator <o>)
   (<ts> ^dialog-context <dc>)
   (<o> ^name interpret-yes-no-message
        ^message <msg>
        ^message-type yes)
   (<dc> ^needs-failure-setup <t> ^learning true ^parsed-failure <msg2>)
-->
   (<msg> ^interpreted true)
 #  (<dc> ^needs-failure-setup <t> -)
   (<s> ^new-segment-info <info>)
   (<info> ^purpose <p>
           ^originator instructor)
   (<p> ^type learn-failure-predicate
        ^parameters.message <msg2>
        ^satisfaction <sat>)
   (<sat> ^learning-event.type game)
}

sp {interpret-message*apply*interpret-yes-no-message*yes*concept-transfer*stored-sentence
   (state <s> ^name interpret-message
              ^top-state <ts>
              ^operator <o>)
   (<ts> ^dialog-context <dc>)
   (<dc> ^learning-predicate <lp> ^transfering <tf>)
   (<lp> ^name <name>)
   (<tf> ^name <name> ^lti <pred> ^to <game>)
   (<o> ^name interpret-yes-no-message
        ^message-type yes)
   (<ts> ^stored-sentence <st> ^unprocessed-next <n>)
   (<st> ^processed <t> ^processed-sentence <pt>
       ^processing-result <pr>)
-->
    (<ts> ^unprocessed-next <n> -)
    (<st> ^processed <t> -)
    (<st> ^processed-sentence <pt> -)
    (<st> ^processing-result <pr> -)
}

sp {interpret-message*apply*interpret-yes-no-message*yes*concept-transfer
   (state <s> ^name interpret-message
              ^top-state <ts>
              ^smem.command <sc>
              ^operator <o>)
   (<ts> ^dialog-context <dc>)
   (<dc> ^learning-predicate <lp> ^transfering <tf>)
   (<lp> ^name <name>)
   (<tf> ^name <name> ^lti <pred> ^to <game>)
   (<o> ^name interpret-yes-no-message
        ^message-type yes)
-->
   (<pred> ^from <game>)
   (<sc> ^store <pred>)
}

sp {interpret-message*apply*interpret-yes-no-message*yes*stored-sentence
   (state <s> ^name interpret-message
              ^top-state <ts>
              ^smem.command <sc>
              ^operator <o>)
   (<ts> ^dialog-context <dc> -^stored-sentence)# ^game-scripting true))
   (<dc> ^learning-predicate <lp> ^transfering <tf> ^stored-sentence <se>)
   (<lp> ^name <name>)
   (<tf> ^name <name> ^lti <pred> ^to <game>)
   (<o> ^name interpret-yes-no-message
        ^message-type <either>)
   (<se> ^next <n1> ^complete-sentence <cs>)#^sentence-number <sn>
-->
    (<dc> ^stored-sentence <se> -)
    (<ts> ^stored-sentence <st>)
    (<st> ^complete-sentence <cs> ^next (deep-copy <n1>) ^spelling *)#^sentence-number (+ 3 <sn>)
}


sp {interpret-message*apply*interpret-yes-no-message*yes*concept-transfer2
   (state <s> ^name interpret-message
              ^top-state <ts>
              #^smem.command <sc>
              ^operator <o>)
   (<ts> ^dialog-context <dc>)
   (<dc> ^learning-predicate <lp> ^transfering <tf>)
   (<lp> ^name <name>)
   (<tf> ^name <name> ^lti <pred> ^to <game>)
   (<pred> ^from <game>)
   (<o> ^name interpret-yes-no-message
        ^message <msg>
        ^message-type yes)
-->
   (<msg> ^interpreted true)
   (<dc> ^learning-predicate <lp> -)
   (<dc> ^transfering <tf> -)
}
#CHUNK vs non chunk stat collection
#sp {interpret-message*apply*interpret-yes-no-message*create*segment*finished-game-learning*datacollect
#   (state <s> ^name interpret-message
#              ^top-state.dialog-context.finished-game-teaching true
#              ^operator <o>)
#   (<o> ^name interpret-yes-no-message
#        ^message-type yes)
#-->
#(write (cmd |ctf -a chunked-stats.txt stats|))
#(halt)
#}

sp {interpret-message*apply*interpret-yes-no-message*create*segment*finished-game-learning
   (state <s> ^name interpret-message
              ^top-state.dialog-context.finished-game-teaching true
              ^operator <o>)
   (<o> ^name interpret-yes-no-message
        ^message-type <yesno>
        ^message <msg>)
-->
   (<s> ^new-segment-info <info>
        ^mark-interpreted <msg>)
   (<info> ^purpose <p>
           ^originator instructor)
   (<p> ^type finished-game-learning
        ^parameters.message <yesno>
        ^satisfaction <sat>)
   (<sat> ^learning-event.type game)
}

#how make sure different handle??
sp {interpret-message*apply*interpret-yes-no-message*no*concept-transfer
   (state <s> ^name interpret-message
              ^top-state <ts>
              ^operator <o>)
   (<ts> ^dialog-context <dc> ^interaction.changes <changes>)
   (<dc> ^learning-predicate <lp> ^transfering <tf>)
   (<lp> ^name <name>)
   (<tf> ^name <name> ^lti <pred> ^to <game>)
   (<o> ^name interpret-yes-no-message
        ^message <msg>
        ^message-type no)
-->
   (<msg> ^interpreted true)
   (<dc> ^transfering <tf> -)
   (<changes> ^outgoing-message <msg2>)
   (<msg2> ^type unknown-word
              ^fields.word <name>)
}    