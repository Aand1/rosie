#TODO
#temp quick version for games, predicates

sp {interpret-message*propose*interpret-unknown-word
   (state <s> ^name interpret-message
          #   -^top-state.dialog-context.learning-predicate.name <word>
              ^instructor-message <msg>)
   (<msg> ^interaction-status.failure <f> 
         -^interpreted true)
   (<f> ^type unknown-word ^word <word>)
-->
   (<s> ^operator <o> + > =)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^message <msg>)
}
sp {interpret-message*prefer*interpret-unknown-word*alphabetic*ordering
   (state <s> ^name interpret-message
              ^operator <o2> +
                ^operator <o> +)
   (<o> ^name interpret-unknown-word
        ^word <word> -^word adjacent)
   (<o2> ^name interpret-unknown-word
         ^word {<w> > <word>})
-->
    (<s> ^operator <o> > <o2>)
}

#prefer adjacent last #need to be able to detect it has two arguments.
sp {interpret-message*prefer*interpret-unknown-word*adjacent
   (state <s> ^name interpret-message
              ^operator <o2> +
                ^operator <o> +)
   (<o> ^name interpret-unknown-word
        -^word adjacent)
   (<o2> ^name interpret-unknown-word
        ^word adjacent)
-->
    (<s> ^operator <o> > <o2>)
}

sp {interpret-message*apply*interpret-unknown-word*store-sentence
   (state <s> ^name interpret-message
            #  ^top-state.dialog-context <dc>
              ^top-state <ts> 
              ^operator <o>)
   (<ts> ^io.input-link.language.sentence <se> -^stored-sentence -^game-scripting true)
   (<o> ^name interpret-unknown-word)
   (<se> ^next <n1> ^complete-sentence <cs>)
-->
    (<ts> ^stored-sentence <st>)
    (<st> ^complete-sentence <cs> ^next (deep-copy <n1>) ^spelling *)#^sentence-number (+ 3 <sn>) 
}

#if learning is stacked
sp {interpret-message*apply*interpret-unknown-word*store-sentence*first*store
   (state <s> ^name interpret-message
            #  ^top-state.dialog-context <dc>
              ^top-state <ts> 
              ^operator <o>)
   (<ts> ^io.input-link.language.sentence <se> ^stored-sentence -^stored-sentence.complete-sentence <cs> -^game-scripting true)
   (<o> ^name interpret-unknown-word)
   (<se> ^next <n1> ^complete-sentence <cs>)
    (<ts> ^dialog-context <dc>)
    (<dc> ^learning-predicate.name <name1>)
    (<dc> ^learning-predicate.name > <name1>) #only if two
-->
 #   (interrupt)
    (<ts> ^next-stored-sentence <st>)
    (<st> ^complete-sentence <cs> ^next (deep-copy <n1>) ^spelling *)#^sentence-number (+ 3 <sn>) 
}

sp {interpret-message*apply*interpret-unknown-word*store-sentence*first*store*game-scripting
   (state <s> ^name interpret-message
            #  ^top-state.dialog-context <dc>
              ^top-state <ts> 
              ^operator <o>)
   (<ts> ^current-sentence <se> ^stored-sentence -^stored-sentence.complete-sentence <cs> ^game-scripting true)
   (<o> ^name interpret-unknown-word)
   (<se> ^next <n1> ^complete-sentence <cs>)
    (<ts> ^dialog-context <dc>)
    (<dc> ^learning-predicate.name <name1>)
    (<dc> ^learning-predicate.name > <name1>) #only if two
-->
    (<ts> ^next-stored-sentence <st>)
    (<st> ^complete-sentence <cs> ^next (deep-copy <n1>) ^spelling *)#^sentence-number (+ 3 <sn>) 
}


sp {interpret-message*apply*interpret-unknown-word*store-sentence*game-scripting
  #  :interrupt
   (state <s> ^name interpret-message
            #  ^top-state.dialog-context <dc>
              ^top-state <ts> 
              ^operator <o>)
   (<ts> ^current-sentence <se> -^stored-sentence ^game-scripting true)
   (<o> ^name interpret-unknown-word)
   (<se> ^next <n1> ^complete-sentence <cs>)
-->
    (<ts> ^stored-sentence <st>)
    (<st> ^complete-sentence <cs> ^next (deep-copy <n1>) ^spelling *)#^sentence-number (+ 3 <sn>) 
}

sp {interpret-message*apply*interpret-unknown-word*store-sentence*processed
   (state <s> ^name interpret-message
              ^top-state <ts> 
              ^operator <o>)
   (<ts> ^stored-sentence <st> ^unprocessed-next <n>)
   (<o> ^name interpret-unknown-word)
   (<st> ^processed <t> ^processed-sentence <pt>
       ^processing-result <pr>)
-->
    (<ts> ^unprocessed-next <n> -)
    (<st> ^processed <t> -)
    (<st> ^processed-sentence <pt> -)
    (<st> ^processing-result <pr> -)
}

sp {interpret-message*apply*interpret-unknown-word*next-store-sentence*processed
   (state <s> ^name interpret-message
              ^top-state <ts> 
              ^operator <o>)
   (<ts> ^next-stored-sentence <st> ^unprocessed-next <n>)
   (<o> ^name interpret-unknown-word)
   (<st> ^processed <t> ^processed-sentence <pt>
       ^processing-result <pr>)
-->
 #   (interrupt)
    (<ts> ^unprocessed-next <n> -)
    (<st> ^processed <t> -)
    (<st> ^processed-sentence <pt> -)
    (<st> ^processing-result <pr> -)
}




######
# OPERATOR ELABORATIONS
######

#####
# OPERATOR APPLICATION
#####

# Mark the message as interpreted (retracts operator)
#   And send message to human
sp {interpret-message*apply*interpret-unknown-word*create*segment
   (state <s> ^name interpret-message
              #^unprocessed-next nil
              ^top-state.dialog-context <dc>
              ^operator <o>)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^message <msg>)
 # -{(<dc> ^learning-predicate <lp2>)
 #   (<lp2> -^name <word>)}
-->
   (<dc> ^learning-predicate <lp>)
   (<lp> ^name <word>)
   (<s> ^mark-interpreted <msg>)
   (<s> ^outgoing-message <out-msg>)
   (<out-msg> ^type unknown-word
              ^fields.word <word>)
}

## stacked unknown words, in future need to have a stack handling
#sp {interpret-message*apply*interpret-unknown-word*create*segment*stacked-unknowns
#   (state <s> ^name interpret-message
#              #^unprocessed-next nil
#              ^top-state.dialog-context <dc>
#              ^operator <o>)
#   (<o> ^name interpret-unknown-word
#        ^word <word>
#        ^message <msg>)
#   (<dc> ^learning-predicate <lp2>)
#   (<lp2> -^name <word>)
#-->
#    (interrupt)
#    (<dc> ^stored-learning-predicate <lp2>)
#   (<dc> ^learning-predicate <lp2> -)
#   (<dc> ^learning-predicate <lp>)
#   (<lp> ^name <word>)
#   (<s> ^mark-interpreted <msg>)
#   (<s> ^outgoing-message <out-msg>)
#   (<out-msg> ^type unknown-word
#              ^fields.word <word>)
#}


#sp {interpret-message*apply*interpret-unknown-word*copy-old-learn-link
#   (state <s> ^name interpret-message
#              ^top-state.dialog-context <dc>
#              ^operator <o>)
#   (<o> ^name interpret-unknown-word
#        ^word <word>
#        ^message <msg>)
#   (<dc> ^learn-link <ll>)
#   (<ll> ^type << action goal >>)
#-->
#    (<dc> ^store-learn-link <ll>)
#    (<dc> ^learn-link <ll> -)
#}



sp {interpret-message*apply*interpret-unknown-word*store-smem-word
   (state <s> ^name interpret-message
              ^smem.command <sc>
              ^operator <o>)
   (<o> ^name interpret-unknown-word
        ^word <word>
       -^word adjacent 
        ^message <msg>)
-->
    (<sc> ^store <w1> <spell> <p3>)
    (<w1> ^handle <word> ^property <p3>)
    (<spell> ^spelling <word> ^structure-type ADJ ^referent <w1>)
    (<p3> ^handle property ^type visual)  
}

sp {interpret-message*apply*interpret-unknown-word*store-smem-word*adjacent
   (state <s> ^name interpret-message
              ^smem.command <sc>
              ^top-state.dialog-context <dc>
              ^operator <o>)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^word adjacent
        ^message <msg>)
-->
    (<sc> ^store <w1> <spell> <next> <next-to1> )
    (<w1> ^handle <word>)
    (<spell> ^spelling <word> ^structure-type P ^converts-to PP ^relation <w1>)
              (<next> ^prior-word <word>
                   ^current-word |to|
                   ^spelling |adjacent-to|  ## Construction?
                   ^structure-type P
                   ^relation <w1>
                   ^assigners <next-to1>
                   ^converts-to PP)
           (<next-to1> ^structure-type DP
                    ^relative-position after
                    ^syntactic-structure head
                    ^required true)
    
    
    
}

    

