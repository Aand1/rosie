# Elaborate the problem-space for primitive actions
sp {action*problem-space*execute*primitive*elaborate*problem-space
   (state <s> ^superstate.problem-space <ss-ps>
              ^superstate.operator <ss-op>)
   (<ss-ps> ^name action
            ^action.type execute)
   (<ss-op> ^action-type primitive)
-->
   (<s> ^problem-space <ps>)
   (<ps> ^name action
         ^action <action>
         ^learning <learn>
         ^world <world>
         ^perception <perc>)
   (<action> ^type execute
             ^action-type primitive)
   (<world> ^copy-type shallow)
   (<perc> ^attend-to-all-perception yes)
}
            
# Elaborate the problem-space for composite actions
sp {action*problem-space*execute*composite*elaborate*problem-space
   (state <s> ^superstate.problem-space <ss-ps>
              ^superstate.operator <ss-op>)
   (<ss-ps> ^name action
            ^action.type execute)
   (<ss-op> ^action-type composite)
-->
   (<s> ^problem-space <ps>)
   (<ps> ^name action
         ^action <action>
         ^learning <learn>
         ^world <world>
         ^perception <perc>)
   (<action> ^type execute
             ^action-type composite)
   (<world> ^copy-type shallow)
   (<perc> ^attend-to-all-perception no)
}

# For a composite action, propose action operators if there is a desired structure (goal) 
#   with at least 1 predicate
sp {action*problem-space*execute*composite*elaborate*problem-space*propose-action-operators
   (state <s> ^problem-space <ps>
              ^desired.predicate)
   (<ps> ^name action
         ^action <a>)
   (<a> ^type execute
        ^action-type composite)
-->
   (<a> ^propose-action-operators true)
}