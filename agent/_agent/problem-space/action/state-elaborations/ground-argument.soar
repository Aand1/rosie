####################### ground-argument ###########################
#
# These rules take a general representation of an action argument
#   and generate a grounded instance 
#
# They fire if a ground-argument structure is on the state
#   (state <s> ^ground-argument <ground-arg>)
#   (<ground-arg> ^arg-type << object concept predicate until-clause >>
#                 ^generalized-rep <rep>) # usually the smem representation of the argument
#   Also expects the following on the state: 
#     action-operator, procedural-id, world

###############################################################
#####                preferences                       ########

sp {anystate*prefer*ground-argument*procedural*over*others
  (state <s> ^ground-argument <arg> 
             ^operator <o1> +
             ^operator <o2> +)
  (<o1> ^name ground-argument
        ^argument <arg>
        ^match-type procedural)
  (<o2> ^name ground-argument
        ^argument <arg>
        ^match-type << default abstract >>)
-->
  (<s> ^operator <o1> > <o2>)
}

sp {anystate*prefer*ground-argument*default*over*others
  (state <s> ^ground-argument <arg> 
             ^operator <o1> +
             ^operator <o2> +)
  (<o1> ^name ground-argument
        ^argument <arg>
        ^match-type default)
  (<o2> ^name ground-argument
        ^argument <arg>
        ^match-type abstract)
-->
  (<s> ^operator <o1> > <o2>)
}

#############################################################
#####                     object                        #####

## object procedural match depth 1
sp {anystate*propose*ground-argument*object*matches*procedural*depth*1
   (state <s> ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.id <obj>)
  (<arg> ^generalized-rep <gen>
          -^instance)
  (<gen> ^arg-type object
         ^id <obj-slot>)
  (<parg> ^arg-type object
          ^id <obj-slot>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type procedural
       ^id <obj>)
}

## object procedural match depth 2
sp {anystate*propose*ground-argument*object*matches*procedural*depth*2
   (state <s> ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.{2} <obj>)
  (<arg> ^generalized-rep <gen>
          -^instance)
  (<gen> ^arg-type object
         ^id <obj-slot>)
  (<parg> ^arg-type predicate
          ^2 <obj-slot>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type procedural
       ^id <obj>)
}


# ENUMERATE: 1-6 predicates on default rep

## object default match with 1 predicate
sp {anystate*propose*ground-argument*object*matches*default*1
   (state <s> ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep <gen>
          -^instance)
   (<gen> ^arg-type object
          ^id.default <def>)
   (<def> ^<prop1> <pred1>)
   -{(<def> ^{ <prop2> <> <prop1> })}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type default
       ^id <obj>)
}

## object default match with 2 predicate
sp {anystate*propose*ground-argument*object*matches*default*2
   (state <s> ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep <gen>
          -^instance)
   (<gen> ^arg-type object
          ^id.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>)
   -{(<def> ^{ <prop3> <> <prop1> <> <prop2> })}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type default
       ^id <obj>)
}

## object default match with 3 predicate
sp {anystate*propose*ground-argument*object*matches*default*3
   (state <s> ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep <gen>
          -^instance)
   (<gen> ^arg-type object
          ^id.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>)
   -{(<def> ^{ <prop4> <> <prop1> <> <prop2> <> <prop3>})}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type default
       ^id <obj>)
}

## object default match with 4 predicate
sp {anystate*propose*ground-argument*object*matches*default*4
   (state <s> ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep <gen>
          -^instance)
   (<gen> ^arg-type object
          ^id.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>)
   -{(<def> ^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4>})}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type default
       ^id <obj>)
}

## object default match with 5 predicate
sp {anystate*propose*ground-argument*object*matches*default*5
   (state <s> ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep <gen>
          -^instance)
   (<gen> ^arg-type object
          ^id.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>
          ^{<prop5> > <prop4>} <pred5>)
   -{(<def> ^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5>})}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>
            ^<prop5> <pred5>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type default
       ^id <obj>)
}

## object default match with 6 predicate
sp {anystate*propose*ground-argument*object*matches*default*6
   (state <s> ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep <gen>
          -^instance)
   (<gen> ^arg-type object
          ^id.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>
          ^{<prop5> > <prop4>} <pred5>
          ^{<prop6> > <prop5>} <pred6>)
  -{(<def> ^{ <prop6> <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5> <> <prop6> })}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>
            ^<prop5> <pred5>
            ^<prop6> <pred6>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type default
       ^id <obj>)
}

## object abstract match
sp {anystate*propose*ground-argument*object*matches*abstract
  (state <s> ^ground-argument <arg>)
   (<arg> ^generalized-rep <gen>
          -^instance)
   (<gen> ^arg-type object
          ^id.default <def>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type abstract
       ^object-rep <def>)
}

### APPLICATION ###

sp {anystate*apply*ground-argument*object*procedural*default*create*instance
  (state <s> ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type << procedural default >>
       ^id <obj>)
-->
  (<arg> ^instance <i>)
  (<i> ^arg-type object
       ^id <obj>)
}

## ENUMERATE: abstract objects with 1-6 predicates in default rep

# ground-argument abstract with 1 predicate
sp {anystate*apply*ground-argument*object*abstract*1*predicate
  (state <s> ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type abstract
       ^object-rep <rep>)
  (<rep> ^<prop1> <pred1>)
  -{(<rep> ^{ <prop2> <> <prop1> })}
-->
  (<arg> ^instance <i>)
  (<i> ^arg-type object
       ^id <obj>)
  (<obj> ^item-type object
         ^predicates <preds>)
  (<preds> ^<prop1> <pred1>)
}

# ground-argument abstract with 2 predicates
sp {anystate*apply*ground-argument*object*abstract*2*predicate
  (state <s> ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type abstract
       ^object-rep <rep>)
   (<rep> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>)
   -{(<rep> ^{ <prop3> <> <prop1> <> <prop2> })}
-->
  (<arg> ^instance <i>)
  (<i> ^arg-type object
       ^id <obj>)
   (<obj> ^item-type object
           ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>)
}

# ground-argument abstract with 3 predicates
sp {anystate*apply*ground-argument*object*abstract*3*predicate
  (state <s> ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type abstract
       ^object-rep <rep>)
   (<rep> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>)
   -{(<rep> ^{ <prop4> <> <prop1> <> <prop2> <> <prop3>})}
-->
  (<arg> ^instance <i>)
  (<i> ^arg-type object
       ^id <obj>)
   (<obj> ^item-type object
           ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>)
}

# ground-argument abstract with 4 predicates
sp {anystate*apply*ground-argument*object*abstract*4*predicate
  (state <s> ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type abstract
       ^object-rep <rep>)
   (<rep> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>)
   -{(<rep> ^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4>})}
-->
  (<arg> ^instance <i>)
  (<i> ^arg-type object
       ^id <obj>)
   (<obj> ^item-type object
           ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>)
}

# ground-argument abstract with 5 predicates
sp {anystate*apply*ground-argument*object*abstract*5*predicate
  (state <s> ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type abstract
       ^object-rep <rep>)
   (<rep> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>
          ^{<prop5> > <prop4>} <pred5>)
   -{(<rep> ^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5>})}
-->
  (<arg> ^instance <i>)
  (<i> ^arg-type object
       ^id <obj>)
   (<obj> ^item-type object
           ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>
            ^<prop5> <pred5>)
}

# ground-argument abstract with 6 predicates
sp {anystate*apply*ground-argument*object*abstract*6*predicate
  (state <s> ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type object
       ^match-type abstract
       ^object-rep <rep>)
   (<rep> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>
          ^{<prop5> > <prop4>} <pred5>
          ^{<prop6> > <prop5>} <pred6>)
  -{(<rep> ^{ <prop6> <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5> <> <prop6> })}
-->
  (<arg> ^instance <i>)
  (<i> ^arg-type object
       ^id <obj>)
   (<obj> ^item-type object
           ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>
            ^<prop5> <pred5>
            ^<prop6> <pred6>)
}


###############################################################
#####                      concept                        #####

sp {anystate*propose*ground-argument*concept*matches*procedural
   (state <s> ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.handle <conc-handle>)
   (<arg> ^generalized-rep <gen>
         -^instance)
   (<gen> ^arg-type concept
          ^id <conc-slot>)
   (<parg> ^arg-type concept
           ^id <conc-slot>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type concept
       ^match-type procedural
       ^handle <conc-handle>)
}

sp {anystate*propose*ground-argument*concept*matches*default
   (state <s> ^ground-argument <arg>)
   (<arg> ^generalized-rep <gen>
         -^instance)
   (<gen> ^arg-type concept
          ^id.default.predicate-handle <conc-handle>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type concept
       ^match-type default
       ^handle <conc-handle>)
}

sp {anystate*apply*ground-argument*concept*create*instance
  (state <s> ^operator <o>)
  (<o> ^name ground-argument
       ^arg-type concept
       ^argument <arg>
       ^handle <conc-handle>)
-->
  (<arg> ^instance <i>)
  (<i> ^arg-type concept
       ^handle <conc-handle>)
}

###############################################################
#####                 predicate-handle                    #####

sp {anystate*propose*ground-argument*predicate-handle*matches*procedural
   (state <s> ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.handle <pred-handle>)
  (<arg> ^generalized-rep <gen>
          -^instance)
  (<gen> ^arg-type predicate-handle
         ^id <pred-slot>)
   (<parg> ^arg-type predicate
           ^id <pred-slot>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type predicate-handle
       ^match-type procedural
       ^handle <pred-handle>)
}

sp {anystate*propose*ground-argument*predicate-handle*matches*default
   (state <s> ^ground-argument <arg>)
   (<arg> ^generalized-rep <gen>
         -^instance)
   (<gen> ^arg-type predicate-handle
          ^id.default.predicate-handle <pred-handle>)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type predicate-handle
       ^match-type default
       ^handle <pred-handle>)
}

sp {anystate*apply*ground-argument*predicate-handle*create*instance
  (state <s> ^operator <o>)
  (<o> ^name ground-argument
       ^arg-type predicate-handle
       ^argument <arg>
       ^handle <pred-handle>)
-->
  (<arg> ^instance <i>)
  (<i> ^arg-type predicate-handle
       ^handle <pred-handle>)
}

###############################################################
#####                    predicate                        #####

sp {anystate*ground-argument*expand*predicate
  (state <s> ^ground-argument <arg>)
  (<arg> ^generalized-rep <gen>)
  (<gen> ^arg-type predicate
         ^id <pred-slot>
         ^2 <obj2-slot>)
-->
  (<s> ^ground-argument <gpred> <gobj2>)
  (<gpred> ^generalized-rep <gen-pred>)
  (<gen-pred> ^arg-type predicate-handle
              ^id <pred-slot>)
  (<gobj2> ^generalized-rep <gen-obj2>)
  (<gen-obj2> ^arg-type object
              ^id <obj2-slot>)
  (<arg> ^ground-handle <gpred>
         ^ground-obj2 <gobj2>)
}

sp {anystate*propose*ground-argument*predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^generalized-rep.arg-type predicate
          ^ground-handle.instance.handle <handle>
          ^ground-obj2.instance.id <obj2>
          -^instance)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type predicate
       ^handle <handle>
       ^2 <obj2>)
}

sp {anystate*apply*ground-argument*predicate*create*instance
  (state <s> ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type predicate
       ^handle <pred-handle>
       ^2 <obj2>)
-->
  (<arg> ^instance <i>)
  (<i> ^arg-type predicate
       ^handle <pred-handle>
       ^2 <obj2>)
}

###############################################################
#####                single-predicate                     #####


## State
sp {anystate*ground-argument*expand*predicate*state
  (state <s> ^ground-argument <arg>)
  (<arg> ^generalized-rep <gen>)
  (<gen> ^type state
         ^id <pred-slot>
         ^1 <obj1-slot>)
-->
  (<s> ^ground-argument <gpred> <gobj1>)

  (<gpred> ^generalized-rep <gen-pred>)
  (<gen-pred> ^arg-type predicate-handle
              ^id <pred-slot>)

  (<gobj1> ^generalized-rep <gen-obj1>)
  (<gen-obj1> ^arg-type object
              ^id <obj1-slot>)

  (<arg> ^ground-handle <gpred>
         ^ground-obj1 <gobj1>)
}

sp {anystate*propose*ground-argument*single-predicate*state
  (state <s> ^ground-argument <arg>)
  (<arg> ^generalized-rep.type state
         ^ground-handle.instance.handle <handle>
         ^ground-obj1.instance.id <obj1>
         -^instance)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type single-predicate
       ^pred-type state
       ^handle <handle>
       ^1 <obj1>)
}


sp {anystate*apply*ground-argument*single-predicate*state*create*instance
  (state <s> ^ground-argument <arg>
             ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type single-predicate
       ^pred-type state
       ^handle <handle>
       ^1 <obj1>)
-->
  (<arg> ^instance <i>)
  (<i> ^type state
       ^handle <handle>
       ^1 <obj1>)
}

### Relation

sp {anystate*ground-argument*expand*predicate*relation
  (state <s> ^ground-argument <arg>)
  (<arg> ^arg-type single-predicate
         ^generalized-rep <gen>)
  (<gen> ^type relation
         ^id <pred-slot>
         ^1 <obj1-slot>
         ^2 <obj2-slot>)
-->
  (<s> ^ground-argument <gpred> <gobj1> <gobj2>)

  (<gpred> ^generalized-rep <gen-pred>)
  (<gen-pred> ^arg-type predicate-handle
              ^id <pred-slot>)

  (<gobj1> ^generalized-rep <gen-obj1>)
  (<gen-obj1> ^arg-type object
              ^id <obj1-slot>)

  (<gobj2> ^generalized-rep <gen-obj2>)
  (<gen-obj2> ^arg-type object
              ^id <obj2-slot>)

  (<arg> ^ground-handle <gpred>
         ^ground-obj1 <gobj1>
         ^ground-obj2 <gobj2>)
}

sp {anystate*propose*ground-argument*single-predicate*relation
  (state <s> ^ground-argument <arg>)
  (<arg> ^arg-type single-predicate
         ^generalized-rep.type relation
         ^ground-handle.instance.handle <handle>
         ^ground-obj1.instance.id <obj1>
         ^ground-obj2.instance.id <obj2>
         -^instance)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type single-predicate
       ^pred-type relation
       ^handle <handle>
       ^1 <obj1>
       ^2 <obj2>)
}


sp {anystate*apply*ground-argument*single-predicate*relation*create*instance
  (state <s> ^ground-argument <arg>
             ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type single-predicate
       ^pred-type relation
       ^handle <handle>
       ^1 <obj1>
       ^2 <obj2>)
-->
  (<arg> ^instance <i>)
  (<i> ^type relation
       ^handle <handle>
       ^1 <obj1>
       ^2 <obj2>)
}

###############################################################
#####                predicate-set                        #####

sp {anystate*ground-argument*expand*predicate-set*1
  (state <s> ^ground-argument <arg>)
  (<arg> ^arg-type predicate-set
         ^generalized-rep <gen>)
  (<gen> ^predicate { <p1>         }
        -^predicate { <p2> <> <p1> })
-->
  (<s> ^ground-argument <gp1>)
  (<gp1> ^arg-type single-predicate
         ^generalized-rep <p1>)
  (<arg> ^ground-pred <gp1>)
}

sp {anystate*ground-argument*expand*predicate-set*2
  (state <s> ^ground-argument <arg>)
  (<arg> ^arg-type predicate-set
         ^generalized-rep <gen>)
  (<gen> ^predicate { <p1>         }
         ^predicate { <p2> > <p1>  }
        -^predicate { <p3> <> <p2> <> <p1> })
-->
  (<s> ^ground-argument <gp1> <gp2>)
  (<gp1> ^arg-type single-predicate
         ^generalized-rep <p1>)
  (<gp2> ^arg-type single-predicate
         ^generalized-rep <p2>)
  (<arg> ^ground-pred <gp1> <gp2>)
}

sp {anystate*ground-argument*expand*predicate-set*3
  (state <s> ^ground-argument <arg>)
  (<arg> ^arg-type predicate-set
         ^generalized-rep <gen>)
  (<gen> ^predicate { <p1>         }
         ^predicate { <p2> > <p1>  }
         ^predicate { <p3> > <p2>  }
        -^predicate { <p4> > <p3> <> <p2> <> <p1> })
-->
  (<s> ^ground-argument <gp1> <gp2> <gp3>)
  (<gp1> ^arg-type single-predicate
         ^generalized-rep <p1>)
  (<gp2> ^arg-type single-predicate
         ^generalized-rep <p2>)
  (<gp3> ^arg-type single-predicate
         ^generalized-rep <p3>)
  (<arg> ^ground-pred <gp1> <gp2> <gp3>)
}

sp {anystate*propose*ground-argument*predicate-set
  (state <s> ^ground-argument <arg>)
  (<arg> ^arg-type predicate-set
        -^instance.predicate)
-->
  (<s> ^operator <o> + =)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type predicate-set)
}

sp {anystate*reject*ground-argument*predicate-set*ungrounded*pred
  (state <s> ^ground-argument <arg>
             ^operator <o> +)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type predicate-set)
  (<arg> ^ground-pred <gp>)
  (<gp> -^instance)
-->
  (<s> ^operator <o> -)
}

sp {anystate*apply*ground-argument*predicate-set*create*instance
  (state <s> ^ground-argument <arg>
             ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type predicate-set)
-->
  (<arg> ^instance <i>)
}

sp {anystate*apply*ground-argument*predicate-set*copy*predicate
  (state <s> ^ground-argument <arg>
             ^operator <o>)
  (<o> ^name ground-argument
       ^argument <arg>
       ^arg-type predicate-set)
  (<arg> ^instance <i>
         ^ground-pred.instance <gp>)
-->
  (<i> ^predicate <gp>)
}

