####################### ground-argument ###########################
#
# These rules take a general representation of an action argument
#   and generate a grounded instance 
#
# They fire if a ground-argument structure is on the state
#   (state <s> ^ground-argument <ground-arg>)
#   (<ground-arg> ^arg-type << object concept predicate until-clause >>
#                 ^arg-status << visible imagined abstract desired >> # optional if not abstract
#                 ^generalized-rep <rep>) # usually the smem representation of the argument
#   Also expects the following on the state: 
#     action-operator, action-id, world

sp {anystate*elaborate*ground-argument*until-predicate*expand*state*predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type until-predicate
          ^generalized-rep <until-pred>)
   (<until-pred> ^type state
                 ^id <pred-rep>
                 ^1 <obj-rep>)
-->
   (<arg> ^id <ground-pred>
          ^1 <ground-obj>)
   (<s> ^ground-argument <ground-pred> <ground-obj>)
   (<ground-pred> ^generalized-rep <pred-rep>
                  ^arg-type predicate)
   (<ground-obj> ^generalized-rep <obj-rep>
                 ^arg-type object)
}

sp {anystate*elaborate*ground-argument*until-predicate*expand*relation*predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type until-predicate
          ^generalized-rep <until-pred>)
   (<until-pred> ^type relation
                 ^id <pred-rep>
                 ^1 <obj1-rep>
                 ^2 <obj2-rep>)
-->
   (<arg> ^id <ground-pred>
          ^1 <ground-obj1>
          ^2 <ground-obj2>)
   (<s> ^ground-argument <ground-pred> <ground-obj1> <ground-obj2>)
   (<ground-pred> ^generalized-rep <pred-rep>
                  ^arg-type predicate)
   (<ground-obj1> ^generalized-rep <obj1-rep>
                  ^arg-type object)
   (<ground-obj2> ^generalized-rep <obj2-rep>
                  ^arg-type object)
}

##### For predicate arguments, lookup the smem structure by the handle ####
sp {anystate*ground-argument*elaborate*smem-query*predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type predicate
          ^instance <pred-handle>)
-->
   (<s> ^smem-query <q>)
   (<q> ^cue.handle <pred-handle>
        ^depth 2)
}

sp {anystate*ground-argument*elaborate*predicate-lti
   (state <s> ^ground-argument <arg>
              ^smem-query <q>)
   (<arg> ^arg-type predicate
          ^instance <pred-handle>)
   (<q> ^cue.handle <pred-handle>
        ^result { <res> <> none })
-->
   (<arg> ^predicate-lti <res>)
}

##### Try to match the argument against procedural slots #####
   
sp {anystate*elaborate*ground-argument*matches*object*depth*1
   (state <s> ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.id <obj>)
   (<arg> ^arg-type object
          ^generalized-rep <obj-slot>)
   (<parg> ^arg-type object
           ^id <obj-slot>)
-->
   (<arg> ^matches-procedural <obj>)
}

sp {anystate*elaborate*ground-argument*matches*object*depth*2
   (state <s> ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.{2} <obj>)
   (<arg> ^arg-type object
          ^generalized-rep <obj-slot>)
   (<parg> ^arg-type predicate
           ^2 <obj-slot>)
-->
   (<arg> ^matches-procedural <obj>)
}

sp {anystate*elaborate*ground-argument*matches*concept
   (state <s> ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.handle <concept-handle>)
   (<arg> ^arg-type concept
          ^generalized-rep <conc-slot>)
   (<parg> ^arg-type concept
           ^id <conc-slot>)
-->
   (<arg> ^matches-procedural <conc-handle>)
}

sp {anystate*elaborate*ground-argument*matches*predicate
   (state <s> ^ground-argument <arg>
              ^procedural-id.<arg-name> <parg>
              ^action-operator.<arg-name>.handle <pred-handle>)
   (<arg> ^arg-type predicate
          ^generalized-rep <pred-slot>)
   (<parg> ^arg-type predicate
           ^id <pred-slot>)
-->
   (<arg> ^matches-procedural <pred-handle>)
}


##### Elaborate the default matches #######

sp {anystate*elaborate*ground-argument*matches-default*concept
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type concept
          ^generalized-rep.default.predicate-handle <handle>)
-->
   (<arg> ^matches-default <handle>)
}

sp {anystate*elaborate*ground-argument*matches-default*predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type predicate
          ^generalized-rep.default.predicate-handle <handle>)
-->
   (<arg> ^matches-default <handle>)
}

sp {anystate*elaborate*ground-argument*matches-default*matches*object*1*predicate
   (state <s> ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep.default <def>)
   (<def> ^<prop1> <pred1>)
   -{(<def> ^{ <prop2> <> <prop1> })}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>)
-->
   (<arg> ^matches-default <obj>)
}

sp {anystate*elaborate*ground-argument*matches-default*matches*object*2*predicate
   (state <s> ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>)
   -{(<def> ^{ <prop3> <> <prop1> <> <prop2> })}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>)
-->
   (<arg> ^matches-default <obj>)
}

sp {anystate*elaborate*ground-argument*matches-default*matches*object*3*predicate
   (state <s> ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>)
   -{(<def> ^{ <prop4> <> <prop1> <> <prop2> <> <prop3>})}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>)
-->
   (<arg> ^matches-default <obj>)
}

sp {anystate*elaborate*ground-argument*matches-default*matches*object*4*predicate
   (state <s> ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>)
   -{(<def> ^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4>})}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>)
-->
   (<arg> ^matches-default <obj>)
}

sp {anystate*elaborate*ground-argument*matches-default*matches*object*5*predicate
   (state <s> ^ground-argument <arg>
              ^world.objects.object <obj>)
   (<arg> ^generalized-rep.default <def>)
   (<def> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>
          ^{<prop5> > <prop4>} <pred5>)
   -{(<def> ^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5>})}
   (<obj> ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>
            ^<prop5> <pred5>)
-->
   (<arg> ^matches-default <obj>)
}

###### elaborate the abstract matches #####
#
sp {anystate*elaborate*ground-argument*generate-abstract*from*generalized-rep*default
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type object
          ^arg-status abstract
          ^generalized-rep.default <def>)
-->
   (<arg> ^generate-abstract <def>)
}

sp {anystate*elaborate*ground-argument*generate-abstract*from*matches-procedural
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type object
          ^arg-status abstract
          ^matches-procedural <proc>)
-->
   (<arg> ^generate-abstract <new>)
}

sp {anystate*elaborate*ground-argument*generate-abstract*from*matches-procedural*predicates
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type object
          ^arg-status abstract
          ^matches-procedural.predicates <preds>
          ^generate-abstract <gen>)
   (<preds> ^{ <prop-name> << modifier1 name category property shape >> } <pred-name>)
-->
   (<gen> ^<prop-name> <pred-name>)
}

sp {anystate*elaborate*ground-argument*matches-abstract*object*1*predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type object
          ^arg-status abstract
          ^generate-abstract <gen>)
   (<gen> ^<prop1> <pred1>)
   -{(<gen> ^{ <prop2> <> <prop1> })}
-->
   (<arg> ^matches-abstract <obj>)
   (<obj> ^item-type object
          ^predicates <preds>)
   (<preds> ^<prop1> <pred1>)
}

sp {anystate*elaborate*ground-argument*matches-abstract*object*2*predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type object
          ^arg-status abstract
          ^generate-abstract <gen>)
   (<gen> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>)
   -{(<gen> ^{ <prop3> <> <prop1> <> <prop2> })}
-->
   (<arg> ^matches-abstract <obj>)
   (<obj> ^item-type object
          ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>)
}

sp {anystate*elaborate*ground-argument*matches-abstract*object*3*predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type object
          ^arg-status abstract
          ^generate-abstract <gen>)
   (<gen> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>)
   -{(<gen> ^{ <prop4> <> <prop1> <> <prop2> <> <prop3>})}
-->
   (<arg> ^matches-abstract <obj>)
   (<obj> ^item-type object
          ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>)
}

sp {anystate*elaborate*ground-argument*matches-abstract*object*4*predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type object
          ^arg-status abstract
          ^generate-abstract <gen>)
   (<gen> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>)
   -{(<gen> ^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4>})}
-->
   (<arg> ^matches-abstract <obj>)
   (<obj> ^item-type object
          ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>)
}

sp {anystate*elaborate*ground-argument*matches-abstract*object*5*predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type object
          ^arg-status abstract
          ^generate-abstract <gen>)
   (<gen> ^<prop1> <pred1>
          ^{<prop2> > <prop1>} <pred2>
          ^{<prop3> > <prop2>} <pred3>
          ^{<prop4> > <prop3>} <pred4>
          ^{<prop5> > <prop4>} <pred5>)
   -{(<gen> ^{ <prop5> <> <prop1> <> <prop2> <> <prop3> <> <prop4> <> <prop5>})}
-->
   (<arg> ^matches-abstract <obj>)
   (<obj> ^item-type object
          ^predicates <preds>)
   (<preds> ^<prop1> <pred1>
            ^<prop2> <pred2>
            ^<prop3> <pred3>
            ^<prop4> <pred4>
            ^<prop5> <pred5>)
}

#### Elaborate the instance #####

sp {anystate*elaborate*ground-argument*instance*matches-procedural
   (state <s> ^ground-argument <arg>)
   (<arg> ^matches-procedural <instance>
          -^arg-status abstract)
-->
   (<arg> ^instance <instance>)
}

sp {anystate*elaborate*ground-argument*instance*matches-default
   (state <s> ^ground-argument <arg>)
   (<arg> -^matches-procedural
           ^matches-default <instance>
           -^arg-status abstract)
-->
   (<arg> ^instance <instance>)
}

sp {anystate*elaborate*ground-argument*instance*matches-imagined
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-status abstract
          ^matches-abstract <abs>)
-->
   (<arg> ^instance <abs>)
}

sp {anystate*elaborate*ground-argument*instance*state*until-predicate*visible
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type until-predicate
          ^generalized-rep.type state
          ^id <id>
          ^{1}.instance <obj1>)
   (<id> ^instance visible1)
-->
   (<arg> ^instance <instance>)
   (<instance> ^type state ^handle visible1 ^property-handle visible1 ^1 <obj1>)
}

sp {anystate*elaborate*ground-argument*instance*state*until-predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type until-predicate
          ^generalized-rep.type state
          ^id <id>
          ^{1}.instance <obj1>)
   (<id> ^instance <pred-handle>
         ^predicate-lti.property.handle <prop-handle>)
-->
   (<arg> ^instance <instance>)
  (<instance> ^type state ^handle <pred-handle> ^property-handle <prop-handle> ^1 <obj1>)
}

sp {anystate*elaborate*ground-argument*instance*relation*until-predicate
   (state <s> ^ground-argument <arg>)
   (<arg> ^arg-type until-predicate
          ^generalized-rep.type relation
          ^id.instance <pred-handle>
          ^{1}.instance <obj1>
          ^{2}.instance <obj2>)
-->
   (<arg> ^instance <instance>)
   (<instance> ^type relation ^handle <pred-handle> ^1 <obj1> ^2 <obj2>)
}
