#has particular final based off type, action, heuristic, predicate, goal
#retrieve structure

sp {evaluate-predicate*eval-condition*impasse
   (state <s> ^superstate  <ss>
              ^choices none
              ^attribute state
              ^impasse no-change)
   (<ss> ^list.game)
-->
   (force-learn <s>) #COMMENT JAMES UNCHUNKED VERSION
   (<s> ^name evaluate-predicate
        ^linkstate <ss>
        ^result <r>)
}

sp {evaluate-predicate*propose*resolve-conditions
   (state <s> ^name evaluate-predicate
         #    -^ntype heuristic
             -^result.set <set>)
-->
   (<s> ^operator <o> + =)
   (<o> ^name resolve-conditions)
}

sp {evaluate-predicate*elaborate*problemspace*games
   (state <s> ^superstate.problemspace {<ps> << games >>})
-->
   (<s> ^problemspace <ps>)
}
sp {learn-predicate*elaborate*learned-actions
   (state <s> ^name learn-predicate
              ^top-state.dialog-context.structure.actions.retrieve-handle <name>
              ^ntype heuristic)
#  -{(<s> ^gtype <gtype> ^<gtype> <g>)
#    (<g> ^condition <co>)
#    (<co> ^type concept ^attribute predicate ^name <n>)
#   -{(<s> ^predicate <p1>)
#      (<p1> ^link <co>)}}
-->
(<s> ^gtype action ^retrieve-handle <name>)# ^main-type action)
}


#sp {evaluate-heuristic*eval-condition*impasse
#   (state <s> ^superstate.superstate <ss>
#              ^choices none
#              ^attribute state
#              ^impasse no-change)
#   (<ss> ^list.game ^ntype heuristic)
#-->
#(interrupt)
#   (force-learn <s>) #COMMENT JAMES UNCHUNKED VERSION
#   (<s> ^name evaluate-heuristic
#        ^linkstate <ss>
#        ^result <r>)
#}
#HEURISTIC CHUNKING COMMENTED OUT BELOW
#sp {evaluate-heuristic*propose*new-operator
#   (state <s> ^name evaluate-heuristic
#              ^linkstate <ss>)
#             # ^result.set <set>)
#   (<ss> ^list.game <g> ^gtype {<type> << action goal >>} ^<type> <t2>)
#   (<t2> ^aname <aname> ^parameter-set.set <set>)
#  # (<g> ^type <type>)
#-->
#   (<ss> ^operator <op> + )
#   (<op> ^name <type>
#         ^aname <aname>
#         ^parameters <set>)
#}


sp {chunk-parameters*propose*new-operatorDEPRICATED
   (state <s> ^name chunk-parameters
              ^superstate <ss>
              ^result.set <set>)
   (<ss> ^list.game <g> ^gtype {<type> predicate} ^<type>.aname <aname>)
   (<g> ^type <type>)
   (<ss> ^<type> <t>)
-->
   (halt)
   (<t> ^pair <set>)
}

sp {chunk-preferences*eval-condition*impasse
   (state <s> ^superstate  <ss>
              #^choices none
              ^attribute operator
              ^impasse tie)
   (<ss> ^list.game ^heuristic <pred>)
   (<pred> ^ntype heuristic)
-->
   (force-learn <s>)
   (<s> ^name chunk-preferences
        ^linkstate <ss>)
}


 sp {chunk-preferences*chunk-parameters*propose*new-operator*snc*t71-4
    (state <s1> ^gtype action ^action <p1> ^list <l1> ^ntype heuristic)
    (<p1> ^parameter-set <p2> ^potential-args <p3>)
    (<p2> ^tested calculate3 ^tested calculate2 ^tested calculate5 ^tested calculate6 
          ^tested calculate4 ^tested calculate1 ^set <s2>)
    (<l1> ^game <g1>)
    -->
    (<p1> ^instance <s2> +)
}

#for now assume parameters are ordered first action mentioned, then second, then ancilary parameters
#assume parameters capture whole action (for now)
sp {chunk-parameters*preference*prefer*single-operators*2args
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^heuristic <pred>)# + ^operator <o2> +)
   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
   (<pref> ^1 <co> -^2)
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>) #^aname <name> 
   (<vs> ^verb-name <name> ^1 <v1> ^2 <v2> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1> ^<v2> <obj2>)
   (<set> ^<i1> <obj1> ^<i2> <obj2>)
   (<co> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<pa1> ^num 2 ^{1}.param-id <i1> ^{2}.param-id <i2>)
-->
   (<ss> ^operator <o1> >)
}

sp {chunk-parameters*preference*prefer*single-operators*1args
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^heuristic <pred>)# + ^operator <o2> +)
   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
   (<pref> ^1 <co> -^2)
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>) #^aname <name> 
   (<vs> ^verb-name <name> ^1 <v1> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1>)
   (<set> ^<i1> <obj1>)
   (<co> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<pa1> ^num 1 ^{1}.param-id <i1>)
-->
   (<ss> ^operator <o1> >)
}
sp {chunk-parameters*preference*disprefer*single-operators*2args
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^heuristic <pred>)# + ^operator <o2> +)
   (<pred> ^disprefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
   (<pref> ^1 <co> -^2)
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>) #^aname <name> 
   (<vs> ^verb-name <name> ^1 <v1> ^2 <v2> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1> ^<v2> <obj2>)
   (<set> ^<i1> <obj1> ^<i2> <obj2>)
   (<co> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<pa1> ^num 2 ^{1}.param-id <i1> ^{2}.param-id <i2>)
-->
   (<ss> ^operator <o1> <)
}
#name not needed? #set should bind (even if another action has same arguments, set wont match
#sp {chunk-parameters*preference*disprefer*single-operators*1args
#   (state <s> ^name chunk-preferences
#              ^superstate <ss>)
#   (<ss> ^operator <o1> + ^heuristic <pred>)# + ^operator <o2> +)
#   (<pred> ^disprefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
#   (<pref> ^1 <co> -^2)
#   (<ps> ^set <set>)
#   (<o1> ^aname <name> ^parameters <set1>)
#   (<set1> ^1 <obj1>)
#   (<set> ^<i1> <obj1>)
#   (<co> ^parameter <pa1> ^type concept ^attribute action ^name <name> ^result.set.instance <set1>)
#   (<pa1> ^num 1 ^{1}.param-id <i1>)
#-->
#   (<ss> ^operator <o1> <)
#}
sp {chunk-parameters*preference*disprefer*single-operators*1args*any
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^heuristic <pred>)# + ^operator <o2> +)
   (<pred> ^disprefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
   (<pref> ^1 <co> -^2)
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>) #^aname <name> 
   (<vs> ^verb-name <name> ^1 <v1> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1>)
   (<set> ^<i1> <obj1>)
   (<co> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<pa1> ^num 1 ^{1}.param-id <i1>)
-->
   (<ss> ^operator <o1> <)
}

sp {chunk-parameters*preference*prefer*two-operators*2args2 #how in general?
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)
   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)
   (<pref> ^1 <co1> ^2 <co2>)   
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>)
   (<vs> ^verb-name <name> ^1 <v1> ^2 <v2> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1> ^<v2> <obj2>)
   (<o2> ^parameters <set2> ^verb-structure.{1} <vs2>)
   (<vs2> ^verb-name <name> ^1 <v3> ^2 <v4> ^verb-prep <vp>)
   (<set2> ^<v3> <obj3> ^<v4> <obj4>)
   (<set> ^<i1> <obj1> ^<i2> <obj2> ^<i3> <obj3> ^<i4> <obj4>)
   (<co1> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<co2> ^parameter <pa2> ^type concept ^attribute action ^result.set.instance <set2> ^name <name> ^verb <vp>)
   (<pa1> ^num 2 ^{1}.param-id <i1> ^{2}.param-id <i2>)
   (<pa2> ^num 2 ^{1}.param-id <i3> ^{2}.param-id <i4>)
-->
   (<ss> ^operator <o1> > <o2>)
}

sp {chunk-parameters*preference*disprefer*two-operators*2args2 #how in general?
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)
   (<pred> ^disprefer <pref> ^ntype heuristic ^parameter-set <ps>)
   (<pref> ^1 <co1> ^2 <co2>)   
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>)
   (<vs> ^verb-name <name> ^1 <v1> ^2 <v2> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1> ^<v2> <obj2>)
   (<o2> ^parameters <set2> ^verb-structure.{1} <vs2>)
   (<vs2> ^verb-name <name> ^1 <v3> ^2 <v4> ^verb-prep <vp>)
   (<set2> ^<v3> <obj3> ^<v4> <obj4>)
   (<set> ^<i1> <obj1> ^<i2> <obj2> ^<i3> <obj3> ^<i4> <obj4>)
   (<co1> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<co2> ^parameter <pa2> ^type concept ^attribute action ^result.set.instance <set2> ^name <name> ^verb <vp>)
   (<pa1> ^num 2 ^{1}.param-id <i1> ^{2}.param-id <i2>)
   (<pa2> ^num 2 ^{1}.param-id <i3> ^{2}.param-id <i4>)
-->
   (<ss> ^operator <o1> < <o2>)
}


#sp {chunk-parameters*preference*disprefer*two-operators*2args2 #how in general?
#   (state <s> ^name chunk-preferences
#              ^superstate <ss>)
#   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)# + ^operator <o2> +)
#   (<pred> ^disprefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
#   (<pref> ^1 <co1> ^2 <co2>)
#   
#   (<ps> ^set <set>)
#  (<o1> ^parameters <set1>)# ^aname <name> 
#   (<o2> ^parameters <set2>)#^aname <name2> 
#   (<set1> ^1 <obj1> ^2 <obj2>)
#   (<set2> ^1 <obj3> ^2 <obj4>)
#   (<set> ^<i1> <obj1> ^<i2> <obj2> ^<i3> <obj3> ^<i4> <obj4>)
#   
#   (<co1> ^parameter <pa1> ^type concept ^attribute action ^name <name> ^result.set.instance <set1>)
#   (<co2> ^parameter <pa2> ^type concept ^attribute action ^name <name2> ^result.set.instance <set2>)
#   (<pa1> ^num 2 ^{1}.param-id <i1> ^{2}.param-id <i2>)
#   (<pa2> ^num 2 ^{1}.param-id <i3> ^{2}.param-id <i4>)
#-->
#   (<ss> ^operator <o1> < <o2>)
#}

sp {chunk-parameters*preference*disprefer*two-operators*2args1 #how in general?
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)
   (<pred> ^disprefer <pref> ^ntype heuristic ^parameter-set <ps>)
   (<pref> ^1 <co1> ^2 <co2>)   
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>)
   (<vs> ^verb-name <name> ^1 <v1> ^2 <v2> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1> ^<v2> <obj2>)
   (<o2> ^parameters <set2> ^verb-structure.{1} <vs2>)
   (<vs2> ^verb-name <name> ^1 <v3> ^verb-prep <vp>)
   (<set2> ^<v3> <obj3>)
   (<set> ^<i1> <obj1> ^<i2> <obj2> ^<i3> <obj3>)
   (<co1> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<co2> ^parameter <pa2> ^type concept ^attribute action ^result.set.instance <set2> ^name <name> ^verb <vp>)
   (<pa1> ^num 2 ^{1}.param-id <i1> ^{2}.param-id <i2>)
   (<pa2> ^num 1 ^{1}.param-id <i3>)
-->
   (<ss> ^operator <o1> < <o2>)
}
sp {chunk-parameters*preference*prefer*two-operators*2args1 #how in general?
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)
   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)
   (<pref> ^1 <co1> ^2 <co2>)   
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>)
   (<vs> ^verb-name <name> ^1 <v1> ^2 <v2> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1> ^<v2> <obj2>)
   (<o2> ^parameters <set2> ^verb-structure.{1} <vs2>)
   (<vs2> ^verb-name <name> ^1 <v3> ^verb-prep <vp>)
   (<set2> ^<v3> <obj3>)
   (<set> ^<i1> <obj1> ^<i2> <obj2> ^<i3> <obj3>)
   (<co1> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<co2> ^parameter <pa2> ^type concept ^attribute action ^result.set.instance <set2> ^name <name> ^verb <vp>)
   (<pa1> ^num 2 ^{1}.param-id <i1> ^{2}.param-id <i2>)
   (<pa2> ^num 1 ^{1}.param-id <i3>)
-->
   (<ss> ^operator <o1> > <o2>)
}
#^above
#sp {chunk-parameters*preference*prefer*two-operators*2args1 #how in general?
#   (state <s> ^name chunk-preferences
#              ^superstate <ss>)
#   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)# + ^operator <o2> +)
#   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
#   (<pref> ^1 <co1> ^2 <co2>)
#   
#   (<ps> ^set <set>)
#   (<o1> ^parameters <set1>)# ^aname <name> 
#   (<o2> ^parameters <set2>)#^aname <name2> 
#   (<set1> ^1 <obj1> ^2 <obj2>)
#   (<set2> ^1 <obj3>)
#   (<set> ^<i1> <obj1> ^<i2> <obj2> ^<i3> <obj3>)
#   
#   (<co1> ^parameter <pa1> ^type concept ^attribute action ^name <name> ^result.set.instance <set1>)
#   (<co2> ^parameter <pa2> ^type concept ^attribute action ^name <name2> ^result.set.instance <set2>)
#   (<pa1> ^num 2 ^{1}.param-id <i1> ^{2}.param-id <i2>)
#   (<pa2> ^num 1 ^{1}.param-id <i3>)
#-->
#   (<ss> ^operator <o1> > <o2>)
#}

sp {chunk-parameters*apply*wait*complete*select*one
   (state <s> ^operator.name wait
              ^quiescence t 
              ^superstate <ss>)
   (<ss> ^name chunk-preferences ^superstate <sss> ^quiescence t)
   (<sss> ^quiescence t ^operator <o> +)
-->
   (<sss> ^operator <o> + =)
}

sp {chunk-parameters*preference*disprefer*two-operators*1args2 #how in general?
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)
   (<pred> ^disprefer <pref> ^ntype heuristic ^parameter-set <ps>)
   (<pref> ^1 <co1> ^2 <co2>)   
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>)
   (<vs> ^verb-name <name> ^1 <v1> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1>)
   (<o2> ^parameters <set2> ^verb-structure.{1} <vs2>)
   (<vs2> ^verb-name <name> ^1 <v3> ^2 <v4> ^verb-prep <vp>)
   (<set2> ^<v3> <obj3> ^<v4> <obj4>)
   (<set> ^<i1> <obj1> ^<i3> <obj3> ^<i4> <obj4>)
   (<co1> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<co2> ^parameter <pa2> ^type concept ^attribute action ^result.set.instance <set2> ^name <name> ^verb <vp>)
   (<pa1> ^num 1 ^{1}.param-id <i1>)
   (<pa2> ^num 2 ^{1}.param-id <i3> ^{2}.param-id <i4>)
-->
   (<ss> ^operator <o1> < <o2>)
}
sp {chunk-parameters*preference*prefer*two-operators*1args2 #how in general?
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)
   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)
   (<pref> ^1 <co1> ^2 <co2>)   
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>)
   (<vs> ^verb-name <name> ^1 <v1> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1>)
   (<o2> ^parameters <set2> ^verb-structure.{1} <vs2>)
   (<vs2> ^verb-name <name> ^1 <v3> ^2 <v4> ^verb-prep <vp>)
   (<set2> ^<v3> <obj3> ^<v4> <obj4>)
   (<set> ^<i1> <obj1> ^<i3> <obj3> ^<i4> <obj4>)
   (<co1> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<co2> ^parameter <pa2> ^type concept ^attribute action ^result.set.instance <set2> ^name <name> ^verb <vp>)
   (<pa1> ^num 1 ^{1}.param-id <i1>)
   (<pa2> ^num 2 ^{1}.param-id <i3> ^{2}.param-id <i4>)
-->
   (<ss> ^operator <o1> > <o2>)
}
#above
#sp {chunk-parameters*preference*prefer*two-operators*1args2 #how in general?
#   (state <s> ^name chunk-preferences
#              ^superstate <ss>)
#   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)# + ^operator <o2> +)
#   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
#   (<pref> ^1 <co1> ^2 <co2>)
#   
#   (<ps> ^set <set>)
#   (<o1> ^parameters <set1>)# ^aname <name> 
#   (<o2> ^parameters <set2>)#^aname <name2> 
#   (<set1> ^1 <obj1>)
#   (<set2> ^1 <obj3> ^2 <obj4>)
#   (<set> ^<i1> <obj1> ^<i3> <obj3> ^<i4> <obj4>)
#   
#   (<co1> ^parameter <pa1> ^type concept ^attribute action ^name <name> ^result.set.instance <set1>)
#   (<co2> ^parameter <pa2> ^type concept ^attribute action ^name <name2> ^result.set.instance <set2>)
#   (<pa1> ^num 1 ^{1}.param-id <i1>)
#   (<pa2> ^num 2 ^{1}.param-id <i3> ^{2}.param-id <i4>)
#-->
#   (<ss> ^operator <o1> > <o2>)
#}

sp {chunk-parameters*preference*prefer*two-operators*1args1 #how in general?
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)
   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)
   (<pref> ^1 <co1> ^2 <co2>)   
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>)
   (<vs> ^verb-name <name> ^1 <v1> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1>)
   (<o2> ^parameters <set2> ^verb-structure.{1} <vs2>)
   (<vs2> ^verb-name <name> ^1 <v2> ^verb-prep <vp>)
   (<set2> ^<v2> <obj2>)
   (<set> ^<i1> <obj1> ^<i2> <obj2>)
   (<co1> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<co2> ^parameter <pa2> ^type concept ^attribute action ^result.set.instance <set2> ^name <name> ^verb <vp>)
   (<pa1> ^num 1 ^{1}.param-id <i1>)
   (<pa2> ^num 1 ^{1}.param-id <i2>)
-->
   (<ss> ^operator <o1> > <o2>)
}
#above
#sp {chunk-parameters*preference*prefer*two-operators*1args1 #how in general?
#   (state <s> ^name chunk-preferences
#              ^superstate <ss>)
#   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)# + ^operator <o2> +)
#   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
#   (<pref> ^1 <co1> ^2 <co2>)
#   
#   (<ps> ^set <set>)
#   (<o1> ^parameters <set1>)# ^aname <name> 
#   (<o2> ^parameters <set2>)#^aname <name2> 
#   (<set1> ^1 <obj1>)
#   (<set2> ^1 <obj2>)
#   (<set> ^<i1> <obj1> ^<i2> <obj2>)
#   
#   (<co1> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1>)
#   (<co2> ^parameter <pa2> ^type concept ^attribute action ^result.set.instance <set2>)
#   (<pa1> ^num 1 ^{1}.param-id <i1>)
#   (<pa2> ^num 1 ^{1}.param-id <i2>)
#-->
#   (<ss> ^operator <o1> > <o2>)
#}

sp {chunk-parameters*preference*disprefer*two-operators*1args1 #how in general?
   (state <s> ^name chunk-preferences
              ^superstate <ss>)
   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)
   (<pred> ^disprefer <pref> ^ntype heuristic ^parameter-set <ps>)
   (<pref> ^1 <co1> ^2 <co2>)   
   (<ps> ^set <set>)
   (<o1> ^parameters <set1> ^verb-structure.{1} <vs>)
   (<vs> ^verb-name <name> ^1 <v1> ^verb-prep <vp>)
   (<set1> ^<v1> <obj1>)
   (<o2> ^parameters <set2> ^verb-structure.{1} <vs2>)
   (<vs2> ^verb-name <name> ^1 <v2> ^verb-prep <vp>)
   (<set2> ^<v2> <obj2>)
   (<set> ^<i1> <obj1> ^<i2> <obj2>)
   (<co1> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1> ^name <name> ^verb <vp>)
   (<co2> ^parameter <pa2> ^type concept ^attribute action ^result.set.instance <set2> ^name <name> ^verb <vp>)
   (<pa1> ^num 1 ^{1}.param-id <i1>)
   (<pa2> ^num 1 ^{1}.param-id <i2>)
-->
   (<ss> ^operator <o1> > <o2>)
}
#above
#sp {chunk-parameters*preference*disprefer*two-operators*1args1
#   (state <s> ^name chunk-preferences
#              ^superstate <ss>)
#   (<ss> ^operator <o1> + ^operator <o2> + ^heuristic <pred>)# + ^operator <o2> +)
#   (<pred> ^disprefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
#   (<pref> ^1 <co1> ^2 <co2>)
#   
#   (<ps> ^set <set>)
#   (<o1> ^parameters <set1>)# ^aname <name> 
#   (<o2> ^parameters <set2>)#^aname <name2> 
#   (<set1> ^1 <obj1>)
#   (<set2> ^1 <obj2>)
#   (<set> ^<i1> <obj1> ^<i2> <obj2>)
#   
#   (<co1> ^parameter <pa1> ^type concept ^attribute action ^result.set.instance <set1>)#^name <name> 
#   (<co2> ^parameter <pa2> ^type concept ^attribute action ^result.set.instance <set2>)#^name <name2> 
#   (<pa1> ^num 1 ^{1}.param-id <i1>)
#   (<pa2> ^num 1 ^{1}.param-id <i2>)
#-->
#   (<ss> ^operator <o1> < <o2>)
#}

#NEED below??


#todo make more subspace search organized
#handle parameters not first or ordered

#sp {copychunk-parameters*propose*new-operator22a #how in general?
#   (state <s> ^name chunk-preferences
#              ^superstate <ss>)
#   (<ss> ^operator <o1> + ^operator <o2> + ^predicate <pred>)# + ^operator <o2> +)
#   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
#   (<pref> ^1 <co1> ^2 <co2>)
#   (<ps> ^argnum 3 ^set <set>)
#   (<o1> ^aname <name> ^parameters <set1>)
#   (<o2> ^aname <name2> ^parameters <set2>)
#   (<set1> ^1 <obj1> ^2 <obj2>)
#   (<set2> ^1 <obj1> ^2 <obj3>)
#   (<set> ^1 <obj1> ^2 <obj2> ^3 <obj3>)
#   
#   (<co1> ^type concept ^attribute action ^name <name>)# ^result.set.instance <set1>) should connect? somehow
#   (<co2> ^type concept ^attribute action ^name <name2>)
#-->
#   (<ss> ^operator <o1> > <o2>)
#}
#sp {chunk-parameters*propose*new-operator22a #how in general?
#   (state <s> ^name chunk-preferences
#              ^superstate <ss>)
#   (<ss> ^operator <o1> + ^operator <o2> + ^predicate <pred>)# + ^operator <o2> +)
#   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
#   (<pref> ^1 <co1> ^2 <co2>)
#   (<ps> ^argnum 2 ^set <set>)
#   (<o1> ^aname <name> ^parameters <set1>)
#   (<o2> ^aname <name2> ^parameters <set2>)
#   (<set1> ^1 <obj1>)
#   (<set2> ^1 <obj2>)
#   (<set> ^1 <obj1> ^2 <obj2>)
#   
#   (<co1> ^type concept ^attribute action ^name <name>)# ^result.set.instance <set1>) should connect? somehow
#   (<co2> ^type concept ^attribute action ^name <name2>)
#-->
#   (<ss> ^operator <o1> > <o2>)
#}
#sp {chunk-parameters*propose*new-operator22a #how in general?
#   (state <s> ^name chunk-preferences
#              ^superstate <ss>)
#   (<ss> ^operator <o1> + ^operator <o2> + ^predicate <pred>)# + ^operator <o2> +)
#   (<pred> ^prefer <pref> ^ntype heuristic ^parameter-set <ps>)# ^condition <co>)
#   (<pref> ^1 <co1> ^2 <co2>)
#   (<ps> ^set <set>)
#   (<o1> ^aname <name> ^parameters <set1>)
#   (<o2> ^aname <name2> ^parameters <set2>)
#   (<set1> ^1 <obj1>)
#   (<set2> ^1 <obj2>)
#   (<set> ^1 <obj1> ^2 <obj2>)
#   
#   (<co1> ^type concept ^attribute action ^name <name>)# ^result.set.instance <set1>) should connect? somehow
#   (<co2> ^type concept ^attribute action ^name <name2>)
#-->
#   (<ss> ^operator <o1> > <o2>)
#}


