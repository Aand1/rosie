
#temporary flag
sp {learn-predicate*elaborate*verb-structure
    :o-support
   (state <s> ^name learn-predicate
              ^gtype action
              ^verb-structure <vs>
              ^action <a>)
-->
    (<a> ^verb-structure <vs>)
}
   
sp {learn-predicate*elaborate*input-args
   (state <s> ^name learn-predicate
              ^gtype <gtype>
             -^top-state.dialog-context.learning-predicate.name <name>
              ^predicate <T5>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name <name> ^args <args>)
   (<args> ^num > 0)
   (<args> ^<a1> <c1>)
   (<c1> ^result.set.instance <in1> ^rtype <rtype>)
   (<T5> ^handle <name> ^link <co> ^condition <c> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125>)
   (<c> ^attribute input-arg ^parameter.{1}.param-id <a1> ^rtype <rtype>)
  # (<nlps> ^aname <name>)
   (<c> ^result.set <res2>)
  # -{(state <s>)?
  #   (<res> -^pair.{1})}
-->
   (<res2> ^instance <in1>)
}
##also test that input has no params
#sp {learn-predicate*elaborate*input-args*set-to-single
#   (state <s> ^name learn-predicate
#              ^gtype <gtype>
#             -^top-state.dialog-context.learning-predicate.name <name>
#              ^predicate <T5>
#              ^<gtype>.condition <co>)
#   (<co> ^type concept ^attribute predicate ^name <name> ^args <args>)
#   (<args> ^num > 0)
#   (<args> ^<a1> <c1>)
#   (<c1> ^rtype set ^parameter.num 0)
#   (<T5> ^link <co> ^condition <c> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125>)
#   (<c> ^attribute input-arg ^parameter.{1}.param-id <a1> ^rtype single)
#   (<nlps> ^aname <name>)
#-->
#   (<c> ^result.set <res>)
#}
sp {learn-predicate*elaborate*input-args*set-to-single*objects
   (state <s> ^name learn-predicate
              ^gtype <gtype>
             -^top-state.dialog-context.learning-predicate.name <name>
              ^predicate <T5>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name <name> ^args <args>)
   (<args> ^num > 0)
   (<args> ^<a1> <c1>)
   (<c1> ^result.set.instance.{1}.<elem> <obj> ^rtype set ^parameter.num 0)
   (<T5> ^link <co> ^condition <c> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125>)
   (<c> ^result.set <res> ^attribute input-arg ^parameter.{1}.param-id <a1> ^rtype single)
   (<nlps> ^aname <name>)
-->
   (<res> ^instance <i15>)
   (<i15> ^1 <obj>)
}

#TODO hack for learning predicate input
#for now just use any object (don't assume labels were important (maybe for future will be, for ambiguous)
sp {learn-predicate*elaborate*input-args*learning-predicate
   (state <s> ^name learn-predicate
              ^top-state.dialog-context.learning-predicate.name <name>
              #^top-state.dialog-context.input-object-1 <obj>)
              ^predicate <T5>)
   (<T5> ^condition <c> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125>)
   (<c> ^attribute input-arg)# ^parameter.{1}.param-id)
   (<nlps> ^aname <name>)
-->
   (<c> ^result.set <res>)
}

sp {learn-predicate*elaborate*input-args*object
   (state <s> ^name learn-predicate
              ^top-state.dialog-context.learning-predicate.name <name>
              ^world.objects.object <obj>
              #^top-state.dialog-context.input-object-1 <obj>)
              ^predicate <T5>)
   (<T5> ^condition <c> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125>)
   (<c> ^attribute input-arg)# ^parameter.{1}.param-id)
   (<nlps> ^aname <name>)
   (<c> ^result.set <res>)
 -->
   (<res> ^instance <in>)
   (<in> ^1 <obj>)
}

sp {learn-predicate*elaborate*tcn
   (state <s> ^name learn-predicate
              ^superstate.operator <op>)
   (<op> ^message <t>
        # ^tcn <tcn>
         ^type {<type> << predicate action goal >>})
-->
   (<s> #^tcn <tcn>  #TEMP HACK PUT BACK
        ^parsed-structure <t>
        ^gtype <type>
        ^main-type <type>
        ^<type> <act>)
  (<act> ^parameter-set <ps>
        ^potential-args <po>)
}
sp {learn-predicate*elaborate*tcn*nlp-set
   (state <s> ^name learn-predicate
              ^superstate.operator <op>)
   (<op> ^nlp-set <nps>
         ^type {<type> << predicate action goal >>})
-->
   (<s> #^tcn <tcn>  #TEMP HACK PUT BACK
        ^parsed-structure <t>
        ^gtype <type>
        ^main-type <type>
        ^<type> <act>)
  (<act> ^parameter-set <ps>
         ^nlp-set <nps>
        ^potential-args <po>)
}

sp {learn-predicate*propose*convert-language-format
   (state <s> ^name learn-predicate
             -^<gtype>.nlp-set
              ^parsed-structure <t>
              ^gtype <gtype>
             -^tcn)
-->
   (<s> ^operator <o> + =)
   (<o> ^name convert-parsed-format
        ^structure <t>)
}

sp {learn-predicate*store*verb-structure
   :o-support
   (state <s> ^name learn-predicate
              ^verb-structure <vs>
              ^top-state.dialog-context <dc>
              ^action <t>)
   (<dc> ^type game-learning ^learn-link <ll>)
-->
   (<ll> ^verb-structure <vs>)
}

sp {learn-predicate*store*structure
   :o-support
   (state <s> ^name learn-predicate
              ^top-state.dialog-context <dc>
              ^gtype {<gtype> << action goal >>}
              ^<gtype> <t>)
   (<t> ^nlp-set.nlp <nlp> ^formated)
   (<dc> ^type game-learning ^learn-link <ll>)
   (<ll> ^predicate-structure <ps>)
-->
   (<ps> ^conditions <nlp>)
}

sp {learn-predicate*store*structure*argnum
   :o-support
   (state <s> ^name learn-predicate
              ^top-state.dialog-context <dc>
              ^gtype {<gtype> << action goal >>}
              ^<gtype> <t>)
   (<t> ^parameter-set.argnum <an>)
   (<dc> ^type game-learning ^learn-link <ll>)
-->
   (<ll> ^argnum <an>)
}
sp {learn-predicate*store*structure*learned-predicate
   :o-support
   (state <s> ^name learn-predicate
              ^top-state.dialog-context <dc>
              ^gtype predicate
              ^main-type predicate
              ^predicate <t>)
   (<t> ^nlp-set <nl> ^formated ^parameter-set.argnum <an>)
   (<dc> ^type game-learning ^learn-link <ll>)
-->
   (<ll> ^predicate-structure <ps> ^argnum <an>)
}

sp {learn-predicate*store*structure*learned-predicate*conditions
   :o-support
   (state <s> ^name learn-predicate
              ^top-state.dialog-context <dc>
              ^gtype predicate
              ^main-type predicate
              ^predicate <t>)
   (<t> ^nlp-set.nlp <nlp> ^formated)
   (<dc> ^type game-learning ^learn-link <ll>)
   (<ll> ^predicate-structure <ps>)
-->
   (<ps> ^conditions <nlp>)
}

#sp {learn-predicate*store*structure*learned-predicate*smem-store
#   :o-support
#   (state <s> ^name learn-predicate
#              ^top-state.dialog-context <dc>
#              ^gtype predicate
#              ^predicate <t>)
#   (<t> ^formated)
#   (<dc> ^type game-learning ^learn-link <ll>)
#   (<ll> ^predicate-structure <ps>)
#   (<ps> ^conditions <nlp>)
#-->
#   (<s> ^store-concept <ll>)
#}


sp {learn-predicate*elaborate*list-games
   (state <s> ^name learn-predicate
             # ^gtype <type>
              ^top-state.dialog-context.name <name>
              ^superstate.operator <op>)
   (<op> ^type <type>)# ^<type>.name <name>)
-->
   (<s> ^list.game <g> ^objects <o> ^simulated true)
   (<g> ^game <name> ^type action predicate) 
   (<s> ^current <g> ^game <name>)
}
sp {learn-predicate*elaborate*actiongoalname
   (state <s> ^name learn-predicate
              ^gtype <type>
              ^<type> <t>)
   (<t> ^nlp-set.aname <aname>)
-->
   (<t> ^aname <aname> ^handle <aname>)
}

sp {learn-predicate*elaborate*handlename
   (state <s> ^name learn-predicate
              ^main-type <type>
              ^<type> <t>)
   (<t> ^handle <aname>)
-->
(<t> ^aname <aname>)
}
#TEMP TEST TODO NEED FOR FORMATTING
sp {learn-predicate*propose*formate-conditions
   (state <s> ^name learn-predicate
              ^main-type <type>
              ^<type> <t>)
   (<t> ^nlp-set <nlp> -^formated <type>)
-->
   (<s> ^operator <o> + = >)
   (<o> ^name format-conditions
        ^type <type>
        ^nlp-set <nlp>)
}

sp {learn-predicate*elaborate*problem-space*predicate-structure
   (state <s> ^name learn-predicate
              ^top-state.world <world2>)
-->
   (<s> ^problem-space.world <world>)
   (<world> ^source <world2>
            ^copy-type deep)
}


sp {learn-predicate*elaborate*sub-conditions
   (state <s> ^name learn-predicate
              ^gtype <type>
              ^<type> <t>)
   (<t> ^condition <co>)
   (<co> ^args.{<arg> << 1 2 3 4 5 6 7 8 9 10 >>} <cond>)
   (<cond> ^name <name>)
-->
   (<t> ^condition <cond>)
}
sp {learn-predicate*elaborate*sub-conditions*predicate
   (state <s> ^name learn-predicate
              ^gtype predicate
              ^predicate <t>)
   (<t> ^nlp-set.conditions <cond>)
-->
   (<t> ^condition <cond>)
}

sp {learn-predicate*elaborate*nlp-set*verb-structure
   # :o-support
   (state <s> ^name learn-predicate
              ^gtype action
              ^action <t>)
   (<t> ^nlp-set.verb-structure <vs>)
-->
(<t> ^verb-structure <vs>)
}

#sp {learn-predicate*apply*copy-top-state*contexts
#   (state <s> ^name learn-predicate
#              ^operator.name copy-top-state
#              ^top-state.{<contexts> << successive dictionary word-pairs integers heuristics >>} <int>)
#-->
#   (<s> ^<contexts> <int>)
#}

