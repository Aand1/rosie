#COMPLETED 6
#TESTED 6 + heuristics
#contains tic-tac-toe board functions

#spatial predicates
#corner
#side
#center
#_x_ win setup
#fork-setup
#_oo block

#heurisitcs here too?
#prefer place center
#prefer place corner over side

sp {topstate*elaborate*center
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name center)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 3)

  (<nlps> ^nlp <cs1> <c4> ^aname center)
   
   
   (<cs1> ^name count ^result.set <res2> ^rtype single ^negative true ^parameter <p3z> ^args <ag1> ^return-type number ^type function ^function soar-count)
   (<ag1> ^2 <cs2> ^num 1)
   (<p3z> ^1 <p1b> ^2 <p2b> ^num 2)
   (<p1b> ^param-id 3 ^type single)
   (<p2b> ^param-id 2 ^type set)
   
   (<c4> ^name number ^rtype single ^negative false ^parameter <p2> ^result.set.pair <resp> ^return-type number)
   (<p2> ^1 <p12d> ^num 1)
   (<p12d> ^param-id 3 ^type single)
   (<resp> ^1 4)
   
   (<c2> ^name location ^parameter.num 0 ^negative false ^args <arg11> ^rtype single ^type attribute ^attribute type ^result.set <rset5>)
   (<arg11> ^1 <c5> ^num 1)
   
   (<cs2> ^name diagonal-with ^rtype set ^negative false ^args <ag5> ^parameter <p3> ^type state-pair ^attribute prepositions ^result.set <rset>)
   (<p3> ^1 <p1d> ^2 <p2d> ^num 2)
   (<p1d> ^param-id 2 ^type set)
   (<p2d> ^param-id 1 ^type single)
   (<ag5> ^1 <c2> ^2 <c2> ^num 2)
   
      (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
   
}
sp {topstate*elaborate*side
   (state <s> ^name learn-param
            #  ^condition.name adjacent
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name side)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)

(<P124> ^argnum 3)

  (<nlps> ^nlp <cs1> <c4> ^aname side)
   
   
   (<cs1> ^name count ^result.set <res2> ^rtype single ^negative true ^parameter <p3z> ^args <ag1> ^return-type number ^type function ^function soar-count)
   (<ag1> ^2 <cs2> ^num 1)
   (<p3z> ^1 <p1b> ^2 <p2b> ^num 2)
   (<p1b> ^param-id 3 ^type single)
   (<p2b> ^param-id 2 ^type set)
   
   (<c4> ^name number ^rtype single ^negative false ^parameter <p2> ^result.set.pair <resp> ^return-type number)
   (<p2> ^1 <p12d> ^num 1)
   (<p12d> ^param-id 3 ^type single)
   (<resp> ^1 2)
   
   (<c2> ^name location ^parameter.num 0 ^negative false ^args <arg11> ^rtype single ^type attribute ^attribute type ^result.set <rset5>)
   (<arg11> ^1 <c5> ^num 1)
   
   (<cs2> ^name diagonal-with ^rtype set ^negative false ^args <ag5> ^parameter <p3> ^type state-pair ^attribute prepositions ^result.set <rset>)
   (<p3> ^1 <p1d> ^2 <p2d> ^num 2)
   (<p1d> ^param-id 2 ^type set)
   (<p2d> ^param-id 1 ^type single)
   (<ag5> ^1 <c2> ^2 <c2> ^num 2)
   
      (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
   
}

sp {topstate*elaborate*corner
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name corner)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
  (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 3)

  (<nlps> ^nlp <cs1> <c4> ^aname corner)
   
   
   (<cs1> ^name count ^result.set <res2> ^rtype single ^negative true ^parameter <p3z> ^args <ag1> ^return-type number ^type function ^function soar-count)
   (<ag1> ^2 <cs2> ^num 1)
   (<p3z> ^1 <p1b> ^2 <p2b> ^num 2)
   (<p1b> ^param-id 3 ^type single)
   (<p2b> ^param-id 2 ^type set)
   
   (<c4> ^name number ^rtype single ^negative false ^parameter <p2> ^result.set.pair <resp> ^return-type number)
   (<p2> ^1 <p12d> ^num 1)
   (<p12d> ^param-id 3 ^type single)
   (<resp> ^1 1)
   
   (<c2> ^name location ^parameter.num 0 ^negative false ^args <arg11> ^rtype single ^type attribute ^attribute type ^result.set <rset5>)
   (<arg11> ^1 <c5> ^num 1)
   
   (<cs2> ^name diagonal-with ^rtype set ^negative false ^args <ag5> ^parameter <p3> ^type state-pair ^attribute prepositions ^result.set <rset>)
   (<p3> ^1 <p1d> ^2 <p2d> ^num 2)
   (<p1d> ^param-id 2 ^type set)
   (<p2d> ^param-id 1 ^type single)
   (<ag5> ^1 <c2> ^2 <c2> ^num 2)
   
      (<c5> ^args <A57> ^attribute primitive ^name object ^negative false
                 ^parameter <P225> ^result <R94> ^rtype single ^type attribute)
            (<P225> ^num 0)
            (<R94> ^set <S158>)
   
}

sp {topstate*elaborate*win-setup
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name win-setup)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 3)


  (<nlps> ^nlp <cs1> ^aname win-setup)

   (<cs> ^result.set <res2> ^name clear ^negative false ^rtype single ^args <agf> ^type concept ^attribute predicate)

   (<c4> ^result.set <res3> ^name own ^negative false ^rtype single ^args <agf2> ^type concept ^attribute predicate)
   
   (<cs1> ^result.set <res> ^rtype single ^negative false ^name linear-with ^args <ag1> ^parameter <pz> ^type state-pair ^attribute prepositions)
   (<pz> ^1 <p1e> ^2 <p2e> ^3 <p3e> ^num 3)
   (<p1e> ^param-id 1 ^type single)
   (<p2e> ^param-id 2 ^type single)
   (<p3e> ^param-id 3 ^type single)
   (<ag1> ^1 <cs> ^2 <c4> ^3 <cs> ^num 3)
 
}
sp {topstate*elaborate*fork-location
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name fork-location)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 5)


  (<nlps> ^nlp <cs1> <cs2> ^aname fork-location)
   
   (<cs1> ^result.set <res> ^rtype single ^negative false ^name win-setup ^args <agasdf1> ^parameter <pz> ^type concept ^attribute predicate)
   (<pz> ^1 <p1e> ^2 <p2e> ^3 <p3e> ^num 3)
   (<p1e> ^param-id 1 ^type single)
   (<p2e> ^param-id 2 ^type single)
   (<p3e> ^param-id 3 ^type single)
   
   (<cs2> ^result.set <res2> ^rtype single ^negative false ^name win-setup ^args <agasdf2> ^parameter <pz2> ^type concept ^attribute predicate)
   (<pz2> ^1 <p1d> ^2 <p2d> ^3 <p3d> ^num 3)
   (<p1d> ^param-id 1 ^type single)
   (<p2d> ^param-id 4 ^type single)
   (<p3d> ^param-id 5 ^type single)
 
}

sp {topstate*elaborate*block-location
   (state <s> ^name learn-param
              ^gtype <gtype>
              ^<gtype>.condition <co>)
   (<co> ^type concept ^attribute predicate ^name block-location)
-->
    (<s> ^predicate <T5> ^gtype predicate)
   
   (<T5> ^nlp-set <nlps> ^formated predicate ^parameter-set <P124> ^potential-args <P125> ^link <co>)
(<P124> ^argnum 3)


  (<nlps> ^nlp <cs1> ^aname block-location)

   (<cs> ^result.set <res2> ^name clear ^negative false ^rtype single ^args <agf> ^type concept ^attribute predicate)

   (<c4> ^result.set <res3> ^name occupied ^negative false ^rtype single ^args <agf2> ^type concept ^attribute predicate)
   
   (<cs1> ^result.set <res> ^rtype single ^negative false ^name linear-with ^args <ag1> ^parameter <pz> ^type state-pair ^attribute prepositions)
   (<pz> ^1 <p1e> ^2 <p2e> ^3 <p3e> ^num 3)
   (<p1e> ^param-id 1 ^type single)
   (<p2e> ^param-id 2 ^type single)
   (<p3e> ^param-id 3 ^type single)
   (<ag1> ^1 <cs> ^2 <c4> ^3 <c4> ^num 3)
 
}