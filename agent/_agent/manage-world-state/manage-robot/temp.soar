#Reject new-stable-object[A] if A.candidate-for-missing-object B and moving[B]
#Reject stale-object[A] if new-object.candidate-for-missing-object A
#Reject stale-object[A] if searching-for-object[A]
#Reject any attend-to-scene-change for object A if moving-object[A]
#Reject any attend-to-scene-change for object A if grabbed[A]
#attend-to-arm: remove all internal links associated with the moved object
#attend-to-arm: create moving-object[A] when the arm starts moving
#attend-to-arm: remove moving-object[A] when the arm stops moving
#attend-to-arm: mark grabbed[A] if there is a grabbed object
#attend-to-arm: remove grabbed[A] if no grabbed object
#attend-to-arm: remove grabbed[A] if no moving-object[A]
#attend-to-arm: if removing grabbed[A], create mark-for-copying[A]

1. send arm command + mark moving-object[A]
2. arm status from wait to grab
3. arm status from grab to [wait, failure]
  ? [wait]
    4. mark action=wait, grabbed[A]
    5. send putdown command
    6. arm status to action=drop
    7. arm status to action=wait, object is [live, stale]
      ? [live]
        8. remove grabbed[A], moving-object[A]
      ? [stale]
        8. remove grabbed[A], moving-object[A], create missing[A]
        9. initiate find-object[A]
        10. either match a new object, or remove the object
  ? [failure]
    6. remove moving-object[A], create missing[A]
    4. send reset command
    5. arm status to action=wait
    7. initiate find-object[A]
    8. either match a new object and try grab again, or remove the object
      

