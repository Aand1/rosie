sp {generate-action-operator*elaborate*message*from*superoperator
   (state <s> ^name generate-action-operator
              ^superstate.operator.command-message <msg>)
-->
   (<s> ^command-message <msg>)
}

sp {generate-action-operator*elaborate*action-id
   (state <s> ^name generate-action-operator
              ^command-message.action <id>)
-->
   (<s> ^action-id <id>)
}

sp {generate-action-operator*elaborate*retrieve-lti*command-message*action
   (state <s> ^name generate-action-operator
              ^action-id <id>)
-->
  (<s> ^smem-retrieve <ret>)
  (<ret> ^identifier <id>
          ^depth 8)
}

sp {generate-action-operator*elaborate*smem-query*predicate
   (state <s> ^name generate-action-operator
              ^command-message.<any> <arg>)
   (<arg> ^item-type << concept predicate property >>
          ^handle <pred-handle>)
-->
   (<s> ^smem-query <q>)
   (<q> ^cue.handle <pred-handle>
        ^depth 4)
}

sp {generate-action-operator*elaborate*task-subaction*from*message
   (state <s> ^name generate-action-operator
              ^command-message.task-subaction <bool>)
-->
   (<s> ^task-subaction <bool>)
}

sp {generate-action-operator*elaborate*task-subaction*default*false
   (state <s> ^name generate-action-operator
             -^command-message.task-subaction)
-->
   (<s> ^task-subaction false)
}

sp {generate-action-operator*elaborate*smem-query*result*predicate-lti
   (state <s> ^name generate-action-operator
              ^command-message.<any> <arg>
              ^smem-query <q>)
   (<arg> ^item-type << concept predicate property >>
          ^handle <pred-handle>)
   (<q> ^cue.handle <pred-handle>
        ^result <pred-lti>)
-->
   (<s> ^predicate-lti <pred-lti>)
}

###### argument-info ######

sp {generate-action-operator*elaborate*argument-info
   (state <s> ^name generate-action-operator
              ^command-message <msg>)
   (<msg> ^{ <arg-name> << arg1 arg2 arg3 arg4 arg5 arg6 relation predicate >> } <arg>)
-->
   (<s> ^argument-info <arg-info>)
   (<arg-info> ^original-name <arg-name> 
               ^value <arg>)
}

sp {generate-action-operator*elaborate*argument-info*procedural
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>
              ^action-id.procedural.<arg-name> <parg>)
   (<arg-info> ^arg-name <arg-name>)
-->
   (<arg-info> ^procedural <parg>)
}

sp {generate-action-operator*elaborate*argument-info*arg-type*object
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^original-name <arg-name>
               ^value.item-type object)
-->
   (<arg-info> ^arg-name <arg-name> 
               ^arg-type object)
}

sp {generate-action-operator*elaborate*arugment-info*arg-type*location
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^original-name <arg-name>
               ^value.item-type location)
-->
   (<arg-info> ^arg-name <arg-name> 
               ^arg-type location)
}

sp {generate-action-operator*elaborate*arugment-info*arg-type*concept
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^original-name <arg-name>
               ^value.item-type concept)
-->
   (<arg-info> ^arg-name <arg-name> 
               ^arg-type concept)
}

sp {generate-action-operator*elaborate*arugment-info*arg-type*concept
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^original-name << arg2 relation predicate >>
               ^value.item-type predicate
              -^value.until-clause)
-->
   (<arg-info> ^arg-name arg2
               ^arg-type predicate)
}

sp {generate-action-operator*elaborate*arugment-info*arg-type*predicate
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^original-name << arg2 relation predicate >>
               ^value.until-clause)
-->
   (<arg-info> ^arg-name until-clause
               ^arg-type until-clause)
}

###### until-clause ######

sp {generate-action-operator*elaboarte*argument-info*until-clause*clause-type*count-shape
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type until-clause
               ^value.until-clause.arg1.predicates.spatial-shape <shape>)
-->
   (<arg-info> ^clause-type count-shape
               ^shape <shape>)
}

sp {generate-action-operator*elaborate*argument-info*until-clause*clause-type*detect-predicate
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type until-clause
               ^value.until-clause.predicate.handle <pred-handle>
               ^value.until-clause.arg1 <obj>)
-->
   (<arg-info> ^clause-type detect-predicate
               ^predicate-handle <pred-handle>
               ^object <obj>)
}

sp {generate-action-operator*elaborate*argument-info*until-clause*count-shape*at*shape
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>
              ^top-state.io.input-link.self.current-waypoint.classification <shape>)
   (<arg-info> ^arg-type until-clause
               ^clause-type count-shape
               ^shape <shape>)
-->
   (<arg-info> ^at-shape true)
}

sp {generate-action-operator*elaborate*argument-info*until-clause*count-shape*from*quantity
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type until-clause
               ^clause-type count-shape
               ^value.until-clause.arg1.predicates.quantity.handle <num>)
-->
   (<arg-info> ^count <num>)
}

sp {generate-action-operator*elaborate*argument-info*until-clause*count-shape*default*1
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type until-clause
               ^clause-type count-shape
               ^value.until-clause.arg1.predicates <preds>)
   (<preds> -^quantity.handle <num>)
-->
   (<arg-info> ^count 1)
}

sp {generate-action-operator*elaborate*argument-info*until-clause*count-shape*final-count*at-shape
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type until-clause
               ^clause-type count-shape
               ^at-shape true
               ^count <c>)
-->
   (<arg-info> ^final-count (+ <c> 1))
}

sp {generate-action-operator*elaborate*argument-info*until-clause*count-shape*final-count*not*at-shape
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type until-clause
               ^clause-type count-shape
              -^at-shape
               ^count <c>)
-->
   (<arg-info> ^final-count <c>)
}

#### object arg-status << visible imagined abstract >> ####

# If the object is on the top-state world and is visible, mark visible
sp {generate-action-operator*elaborate*argument-info*arg-status*visible
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>
              ^top-state.world.objects.object <obj>)
   (<arg-info> ^arg-type << object location >>
               ^value <obj>)
   (<obj> ^predicates.visible true)
-->
   (<arg-info> ^arg-status visible)
}

# Object is on top-state world but not visible - imagined
sp {generate-action-operator*elaborate*argument-info*arg-status*imagined*not*visible
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>
              ^top-state.world.objects.object <obj>)
   (<arg-info> ^arg-type << object location >>
               ^value <obj>)
   (<obj> ^predicates.visible false)
-->
   (<arg-info> ^arg-status imagined)
}

# Object is not on the world - imagined
sp {generate-action-operator*elaborate*argument-info*arg-status*imagined*not*on*world
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>
              -^top-state.world.objects.object <obj>)
   (<arg-info> ^arg-type << object location >>
              -^procedural.arg-status abstract
               ^value <obj>)
-->
   (<arg-info> ^arg-status imagined)
}

# Object is not on the world and is labeled as abstract - abstract
sp {generate-action-operator*elaborate*argument-info*arg-status*abstract*not*on*world
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>
              -^top-state.world.objects.object <obj>)
   (<arg-info> ^arg-type << object location >>
               ^procedural.arg-status abstract
               ^value <obj>)
-->
   (<arg-info> ^arg-status abstract)
}


#### concept arg-status << abstract >> #####

# concepts are always abstract
sp {generate-action-operator*elaborate*argument-info*concept*arg-status*default*abstract
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type concept)
-->
   (<arg-info> ^arg-status abstract)
}


#### predicate arg-status << visible imagined abstract desired >> #####

# predicate by default is visible
sp {generate-action-operator*elaborate*argument-info*predicate*arg-status*default*visible
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>)
   (<arg-info> ^arg-type predicate
              -^arg-status <> visible)
-->
   (<arg-info> ^arg-status visible)
}

# If the predicate exists on the top-state, mark as visible
sp {generate-action-operator*elaborate*argument-info*predicate*arg-status*visible
   (state <s> ^name generate-action-operator
              ^predicate-lti <pred-info>
              ^argument-info <arg1-info>
              ^argument-info <arg2-info>
              ^top-state.world.predicates.predicate <ts-pred>)
   (<pred-info> ^handle <pred-handle>
               -^spatial-relation
                ^relation-type existing)
   (<arg1-info> ^arg-name arg1
                ^value <obj1>)
   (<arg2-info> ^arg-name arg2
                ^arg-type predicate
                ^value.handle <pred-handle>
                ^value.{2} <obj2>)
   (<ts-pred> ^handle <pred-handle>
              ^instance <i>)
   (<i> ^1 <obj1> ^2 <obj2>)
-->
   (<arg2-info> ^arg-status visible)
}

# If the predicate exists on the top-state (in the form of the spatial-relation it is an alias for) - mark as visible
sp {generate-action-operator*elaborate*argument-info*predicate*arg-status*visible*2
   (state <s> ^name generate-action-operator
              ^predicate-lti <pred-info>
              ^argument-info <arg1-info>
              ^argument-info <arg2-info>
              ^top-state.world.predicates.predicate <ts-pred>)
   (<pred-info> ^handle <pred-handle>
                ^spatial-relation.handle <rel-handle>
                ^relation-type existing)
   (<arg1-info> ^arg-name arg1
                ^value <obj1>)
   (<arg2-info> ^arg-name arg2
                ^arg-type predicate
                ^value.handle <pred-handle>
                ^value.{2} <obj2>)
   (<ts-pred> ^handle <rel-handle>
              ^instance <i>)
   (<i> ^1 <obj1> ^2 <obj2>)
-->
   (<arg2-info> ^arg-status visible)
}

# If the predicate is not on the top-state, mark as imagined
sp {generate-action-operator*elaborate*argument-info*predicate*arg-status*imagined
   (state <s> ^name generate-action-operator
              ^predicate-lti <pred-info>
              ^argument-info <arg1-info>
              ^argument-info <arg2-info>
              ^top-state.world.predicates.predicate <ts-pred>)
   (<pred-info> ^handle <pred-handle>
               -^spatial-relation
                ^relation-type existing)
   (<arg1-info> ^arg-name arg1
                ^value <obj1>)
   (<arg2-info> ^arg-name arg2
                ^arg-type predicate
                ^value.handle <pred-handle>
                ^value.{2} <obj2>)
   (<ts-pred> ^handle <pred-handle>)
   -{(<ts-pred> ^instance <i>)
     (<i> ^1 <obj1> ^2 <obj2>)}
-->
   (<arg2-info> ^arg-status imagined)
}

# If the predicate is not on the top-state (in the form of the one it is an alias for) - imagined
sp {generate-action-operator*elaborate*argument-info*predicate*arg-status*imagined*2
   (state <s> ^name generate-action-operator
              ^predicate-lti <pred-info>
              ^argument-info <arg1-info>
              ^argument-info <arg2-info>
              ^top-state.world.predicates.predicate <ts-pred>)
   (<pred-info> ^handle <pred-handle>
                ^spatial-relation.handle <rel-handle>
                ^relation-type existing)
   (<arg1-info> ^arg-name arg1
                ^value <obj1>)
   (<arg2-info> ^arg-name arg2
                ^arg-type predicate
                ^value.handle <pred-handle>
                ^value.{2} <obj2>)
   (<ts-pred> ^handle <rel-handle>)
   -{(<ts-pred> ^instance <i>)
     (<i> ^1 <obj1> ^2 <obj2>)}
-->
   (<arg2-info> ^arg-status imagined)
}

# If the predicate represents a desired relation - mark as desired
sp {generate-action-operator*elaborate*argument-info*predicate*arg-status*desired
   (state <s> ^name generate-action-operator
              ^argument-info <arg-info>
              ^predicate-lti <pred-info>)
   (<arg-info> ^arg-type predicate
               ^value.handle <pred-handle>)
   (<pred-info> ^handle <pred-handle>
                ^relation-type desired)
-->
   (<arg-info> ^arg-status desired)
}

