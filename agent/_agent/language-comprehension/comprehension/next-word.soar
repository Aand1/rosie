sp {comprehension*propose*next-word
   (state <s> ^name comprehension
              ^segment <seg>)
   (<seg> ^input-sentence.spelling
          ^current-word <cw>)
   (<cw> ^processed true)
-->
   (<s> ^operator <o> + =, <)
   (<o> ^name next-word)
}

sp {comprehension*apply*next-word
   (state <s> ^operator.name next-word
              ^segment <seg>)
   (<seg> ^input-sentence <i>
          ^current-word <old-w>
          ^prior-word <pw>)
   (<i> ^next { <> nil <n> })
-->
   (<seg> ^input-sentence <i> - # throw away word from input queue
                          <n>
          ^current-word <n>
                        <old-w> -
          ^prior-word <pw> -
                      <old-w>)
}

sp {comprehension*apply*next-word*nil*missing-period
   (state <s> ^operator.name next-word
              ^segment <seg>)
   (<seg> ^input-sentence <i>
          ^current-word <old-w>
          ^prior-word <pw>)
   (<i> ^next nil)
-->
   (<i> ^next <next>)
   (<next> ^spelling |.|
           ^next nil)
   (<seg> ^input-sentence <i> - # throw away word from input queue
                          <next>
          ^current-word <next>
                        <old-w> -
          ^prior-word <pw> -
                      <old-w>)
}

sp {comprehension*apply*next-word*no-prior
   (state <s> ^operator.name next-word
              ^segment <seg>)
   (<seg> ^input-sentence <i>
          ^current-word <old-w>
         -^prior-word <pw>)
   (<i> ^next <n>)
-->
   (<seg> ^input-sentence <i> - # throw away word from input queue
                          <n>
          ^current-word <n>
                        <old-w> -
          ^prior-word <old-w>)
}
sp {comprehension*apply*next-word*clean-up-processed-next-word
   (state <s> ^operator.name next-word
              ^segment <seg>)
   (<seg> ^input-sentence <i>)
   (<i> ^next <n>)
   (<n> ^processed true)
-->
   (<n> ^processed true -)
}

