##!
# @file
#
# @created plindes 20150706
# File: check-expectation.soar
# Author: Peter Lindes
# Created: 6 July 2015
#
# Desc: Check to see if a completed parse meets the given expectation.
#
#
#

#   Propose an operator to check the expectation
sp {check-failure*propose*check-expectation
   (state <s> ^name termination-processing
              ^checked-not-merged-receivers true
              ^checked-not-merged-assigners true
              ^superstate.segment <seg>)
   (<seg> -^parse-failed-receiver
          -^parse-failed-assigner
          -^processed-terminator true)
   (<seg> ^original-sentence <cs>)
   (<cs> ^processed-sentence true)
-->
   (<s> ^operator <op> + =)
   (<op> ^name check-expectation)
}

sp {check-failure*apply*check-expectation*no-expectation
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^expected nil)
-->
   (<seg> ^checked-expectation true
          ^processed-terminator true)
   (<ts> ^terminated-sentence <csn>
         ^success-count <sc> - 
                       (+ <sc> 1))
   (write (crlf) (concat |NO EXPECTATION PROVIDED for sentence | <csn> |.|))
#   (interrupt)
}

#   At L1:   (x ^a ) is missing  - FAIL
sp {check-failure*apply*check-expectation*l1-attribute-missing
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr> <value>)
   (<sem> -^<attr> )
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION FAILED: '| <sem> | ^| <attr> |' missing.|))
#   (interrupt)
}

#   At L1:   (x ^a c) == (y ^a c) - PASS
sp {check-failure*apply*check-expectation*l1-constant-match
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> -^<attr> {<=> <s>})  # NOT an identifier
   (<expected> ^<attr> <value>)
   (<sem> ^<attr> <value>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION MATCHED: '| <sem> | ^| <attr> | | <value> |' found.|))
#   (interrupt)
}

#   At L1:   (x ^a c) <> (y ^a d) - FAIL
sp {check-failure*apply*check-expectation*l1-constant-fail
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> -^<attr> {<=> <s>})  # NOT an identifier
   (<expected> ^<attr> <value>)
   (<sem> ^<attr> <v2> <> <value>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION FAILED: '| <sem> | ^| <attr> |' | <value> | <> | <v2> |.|))
#   (interrupt)
}

#   At L1:   (x ^a <c>) <> (y ^a d) - FAIL
sp {check-failure*apply*check-expectation*l1-identifier-fail
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr> {<=> <s>})  # IS an identifier
   (<expected> ^<attr> <value>)
   (<sem> -^<attr> <v2> {<=> <s>})  # NOT an identifier
   (<sem> ^<attr> <v2> <> <value>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION FAILED: '| <sem> | ^| <attr> |' | <value> | <> | <v2> |.|))
#   (interrupt)
}

#   At L1:   (x ^a <w>),  (y ^a <z>), <w> has no children - PASS
#   If there are children, we have to check at level 2
sp {check-failure*apply*check-expectation*l1-identifier-match-no-children
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr> {<=> <s>})  # IS an identifier
   (<expected> ^<attr> <value>)
  -(<value> ^<attr-x> )
   (<sem> ^<attr> <v2>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION MATCHED: '| <sem> | ^| <attr> | | <v2> |' found.|))
#   (interrupt)
}

#   At L2:   (x ^a ) is missing  - FAIL
sp {check-failure*apply*check-expectation*l2-attribute-missing
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr1> <expected2>)
   (<sem> ^<attr1> <sem2>)
   (<expected2> ^<attr2> <value>)
   (<sem2> -^<attr2> )
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION FAILED: '| <sem> | ^| <attr1> |.| <attr2> |' missing.|))
#   (interrupt)
}

#   At L2:   (x ^a c) == (y ^a c) - PASS
sp {check-failure*apply*check-expectation*l2-constant-match
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr1> <expected2>)
   (<sem> ^<attr1> <sem2>)
   (<expected2> -^<attr2> {<=> <s>})  # NOT an identifier
   (<expected2> ^<attr2> <value>)
   (<sem2> ^<attr2> <value>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION MATCHED: '| <sem> | ^| <attr1> |.| <attr2> | | <value> |' found.|))
#   (interrupt)
}

#   At L2:   (x ^a c) <> (y ^a d) - FAIL
sp {check-failure*apply*check-expectation*l2-constant-fail
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr1> <expected2>)
   (<sem> ^<attr1> <sem2>)
   (<expected2> -^<attr2> {<=> <s>})  # NOT an identifier
   (<expected2> ^<attr2> <value>)
   (<sem2> ^<attr2> <v2> <> <value>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION FAILED: '| <sem> | ^| <attr1> |.| <attr2> |' | <value> | <> | <v2> |.|))
#   (interrupt)
}

#   At L2:   (x ^a <c>) <> (y ^a d) - FAIL
sp {check-failure*apply*check-expectation*l2-identifier-fail
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr1> <expected2>)
   (<sem> ^<attr1> <sem2>)
   (<expected2> ^<attr2> {<=> <s>})  # IS an identifier
   (<expected2> ^<attr2> <value>)
   (<sem2> -^<attr2> <v2> {<=> <s>})  # NOT an identifier
   (<sem2> ^<attr2> <v2> <> <value>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION FAILED: '| <sem> | ^| <attr1> |.| <attr2> |' | <value> | <> | <v2> |.|))
#   (interrupt)
}

#   At L2:   (x ^a <w>),  (y ^a <z>), <w> has no children - PASS
#   If there are children, we have to check at level 3
sp {check-failure*apply*check-expectation*l2-identifier-match-no-children
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr1> <expected2>)
   (<sem> ^<attr1> <sem2>)
   (<expected2> ^<attr2> {<=> <s>})  # IS an identifier
   (<expected2> ^<attr2> <value>)
  -(<value> ^<attr-x> )
   (<sem2> ^<attr2> <v2>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION MATCHED: '| <sem> | ^| <attr1> |.| <attr2> | | <v2> |' found.|))
#   (interrupt)
}

#   At L3:   (x ^a ) is missing  - FAIL
sp {check-failure*apply*check-expectation*l3-attribute-missing
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr1> <expected2>)
   (<sem> ^<attr1> <sem2>)
   (<expected2> ^<attr2> <expected3>)
   (<sem2> ^<attr2> <sem3>)
   (<expected3> ^<attr3> <value>)
   (<sem3> -^<attr3> )
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION FAILED: '| <sem> | ^| <attr1> |.| <attr2> |.| <attr3> |' missing.|))
#   (interrupt)
}

#   At L3:   (x ^a c) == (y ^a c) - PASS
sp {check-failure*apply*check-expectation*l3-constant-match
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr1> <expected2>)
   (<sem> ^<attr1> <sem2>)
   (<expected2> ^<attr2> <expected3>)
   (<sem2> ^<attr2> <sem3>)
   (<expected3> -^<attr3> {<=> <s>})  # NOT an identifier
   (<expected3> ^<attr3> <value>)
   (<sem3> ^<attr3> <value>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION MATCHED: '| <sem> | ^| <attr1> |.| <attr2> |.| <attr3> | | <value> |' found.|))
#   (interrupt)
}

#   At L3:   (x ^a c) <> (y ^a d) - FAIL
sp {check-failure*apply*check-expectation*l3-constant-fail
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr1> <expected2>)
   (<sem> ^<attr1> <sem2>)
   (<expected2> ^<attr2> <expected3>)
   (<sem2> ^<attr2> <sem3>)
   (<expected3> -^<attr3> {<=> <s>})  # NOT an identifier
   (<expected3> ^<attr3> <value>)
   (<sem3> ^<attr3> <v2> <> <value>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION FAILED: '| <sem> | ^| <attr1> |.| <attr2> |.| <attr3> |' | <value> | <> | <v2> |.|))
#   (interrupt)
}

#   At L3:   (x ^a <c>) <> (y ^a d) - FAIL
sp {check-failure*apply*check-expectation*l3-identifier-fail
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr1> <expected2>)
   (<sem> ^<attr1> <sem2>)
   (<expected2> ^<attr2> <expected3>)
   (<sem2> ^<attr2> <sem3>)
   (<expected3> ^<attr3> {<=> <s>})  # IS an identifier
   (<expected3> ^<attr3> <value>)
   (<sem3> -^<attr3> <v2> {<=> <s>})  # NOT an identifier
   (<sem3> ^<attr3> <v2> <> <value>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION FAILED: '| <sem> | ^| <attr1> |.| <attr2> |.| <attr3> |' | <value> | <> | <v2> |.|))
#   (interrupt)
}

#   At L3:   (x ^a <w>),  (y ^a <z>), <w> has no children - PASS
#   If there are children, we have to check at level 4
sp {check-failure*apply*check-expectation*l3-identifier-match-no-children
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^original-sentence <cs>
          ^expected <expected>
          ^semantics <sem>)
   (<cs> ^processed-sentence true)
   (<expected> ^<attr1> <expected2>)
   (<sem> ^<attr1> <sem2>)
   (<expected2> ^<attr2> <expected3>)
   (<sem2> ^<attr2> <sem3>)
   (<expected3> ^<attr3> {<=> <s>})  # IS an identifier
   (<expected3> ^<attr3> <value>)
#  -(<value> ^<attr-x> )    #   Only do this check if level 4 implemented
   (<sem3> ^<attr3> <v2>)
-->
   (<seg> ^checked-expectation true)
   (write (crlf) (concat |EXPECTATION MATCHED: '| <sem> | ^| <attr1> |.| <attr2> |.| <attr3> | | <v2> |' found.|))
#   (interrupt)
}

sp {check-failure*apply*check-expectation*done
   (state <s> ^operator <op>
              ^top-state.world-usage internal
              ^segment <seg>
              ^top-state <ts>
             -^failed-receiver
             -^failed-assigner)
   (<op> ^name check-expectation)
   (<ts> ^current-sentence-number <csn>
         ^success-count <sc>)
   (<seg> ^checked-expectation true)
-->
   (<seg> ^processed-terminator true)
   (<ts> ^terminated-sentence <csn>
         ^success-count <sc> - 
                       (+ <sc> 1))
#   (interrupt)
}

########

sp {apply*check-expectation*new-message
   (state <s> ^name termination-processing
              ^operator.name  check-expectation
             #-^top-state.world-usage internal
             -^failed-receiver
             -^failed-assigner
              ^segment <seg>
              ^top-state.interaction.status <status>)
   (<seg> ^checked-expectation true
          ^semantics <sem>)
   (<sem> ^message-type <ms-type>)
-->
   (<status> ^new-message <sem>)
}

sp {apply*check-expectation-interaction-status
   (state <s> ^name termination-processing
              ^operator.name  check-expectation
             #-^top-state.world-usage internal
             -^failed-receiver
             -^failed-assigner
              ^segment <seg>
              ^top-state.interaction.status <status>)
   (<seg> ^checked-expectation true
          ^semantics <sem>)
   (<sem> ^interaction-status.<att> <value>)
-->
   (<status> ^<att> <value>)
}

###########################################################
#   SOME EXAMPLES OF TYPE CHECKING - COURTESY OF Justin Li
#sp {iden-different-types
#    (state <s> ^x <x>
#               ^y <y>)
#    (<x> ^z {<val> <=> <s>})
#   -(<y> ^z {<=> <val>})
#-->
#    # fail
#}
#
#sp {iden-same-types
#    (state <s> ^x <x>
#               ^y <y>)
#    (<x> ^z {<val> <=> <s>})
#    (<y> ^z {<=> <val>})
#-->
#    # pass
#}
#
#sp {const-different-types
#    (state <s> ^x <x>
#               ^y <y>)
#    (<x> ^z <val>)
#   -(<x> ^z {<=> <s>})
#   -(<y> ^z {<=> <val>})
#-->
#    # fail
#}
#
#sp {const-same-types
#    (state <s> ^x <x>
#               ^y <y>)
#    (<x> ^z <val>)
#   -(<x> ^z {<=> <s>})
#    (<y> ^z <val>)
#-->
#    # pass
#}
