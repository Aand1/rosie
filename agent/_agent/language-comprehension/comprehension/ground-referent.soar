sp {comprehension*propose*ground-referent
  # :interrupt
   (state <s> ^name comprehension
              ^segment.last-merge <lm>)
   (<lm> ^assigner <as>
         ^receiver <r1>)
   (<as> ^parent-receiver { <> <r1> <a1> }
         ^structure-type)
   (<a1> ^structure-type DP
        -^head.lt.referent nil
        -^head.lt.referent-type literal-lti
        -^head.head.lt.referent nil
        -^head.head.lt.referent-type literal-lti
        -^ground-tested <r1>
        -^ground-tested <a1>)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name ground-referent
         ^constraints <a1>
         ^parameter <r1>)
}

sp {comprehension*propose*ground-referent*push*head
   (state <s> ^name comprehension
              ^segment.last-merge <lm>)
   (<lm> ^assigner <as>
         ^receiver <r1>)
   (<as> ^parent-receiver <a1>
         ^structure-type
        -^lt.referent-type literal-lti)    # JEL
   (<r1> ^structure-type { <st> << THIS THAT DP >> }
        -^ground-tested <head>)
   (<a1> ^head <head>
        -^ground-tested <head>
        -^head.lt.referent nil
        -^head.lt.referent-type literal-lti
        -^head.head.lt.referent nil
        -^head.head.lt.referent-type literal-lti)
   (<head> ^structure-type <st>
          -^ground-tested) # <head>)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name ground-referent
         ^constraints <head>
         ^parameter <head>)
}

sp {comprehension*propose*ground-referent*push*complement
   (state <s> ^name comprehension
              ^segment.last-merge <lm>)
   (<lm> ^assigner <as>
         ^receiver <r1>)
   (<as> ^parent-receiver <a1>
         ^structure-type)
   (<r1> ^structure-type { <st> << THIS THAT DP >> }
        -^ground-tested <head>)
   (<a1> ^complement <head>
        -^ground-tested <head>
        -^complement.lt.referent nil
        -^complement.lt.referent-type literal-lti
        -^complement.head.lt.referent nil
        -^complement.head.lt.referent-type literal-lti)
   (<head> ^structure-type <st>
          -^ground-tested <head>)
  -(<head> ^head <head2>
           ^ground-tested <head2>)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name ground-referent
         ^constraints <head>
         ^parameter <head>)
}


sp {comprehension*propose*ground-referent*push*complement2
   (state <s> ^name comprehension
              ^segment.last-merge <lm>)
   (<lm> ^assigner <as>
         ^receiver <r1>)
   (<as> ^parent-receiver <a1>
         ^structure-type)
   (<r1> ^structure-type PP
        -^ground-tested <head>)
   (<a1> ^complement2 <c2>
        -^ground-tested <head>
        -^complement2.lt.referent nil
        -^complement2.lt.referent-type literal-lti
        -^complement2.head.lt.referent nil
        -^complement2.head.lt.referent-type literal-lti
        -^complement2.head.head.lt.referent-type literal-lti
        -^complement2.head.head.lt.referent nil)
   (<c2> ^head <head>)
   (<head> ^structure-type DP
          -^ground-tested <head>)
  -(<cons> ^ground-tested <cons>)  #<head> 
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name ground-referent
         ^constraints <cons>
         ^double-constraints <c2> <head>  # constraints from both
         ^parameter <head>)
}

sp {comprehension*elaborate-operator*ground-referent*lt
   (state <s> ^name comprehension
              ^operator <o> +)
   (<o> ^name ground-referent
        ^constraints <con>)
   (<con> ^lt.constraint <x>)
-->
   (<con> ^constraint <x>)
}

sp {comprehension*elaborate-operator*ground-referent
   (state <s> ^name comprehension
              ^operator <o> +)
   (<o> ^name ground-referent
        ^constraints <con>
        ^double-constraints.constraint <x>)
-->
   (<con> ^constraint <x>)
}


sp {comprehension*compare*ground-referent
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name ground-referent)
   (<op2> ^name process-phrase-end)
-->
   (<s> ^operator <op1> > <op2>)
}

# Avoid ground reference if referent nil will occur in future merge!
sp {comprehension*compare*ground-referent*merge
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name ground-referent
          ^constraints.structure-type DP)
   (<op2> ^name merge 
          ^assigner <ass>)
   (<ass> ^structure-type DP
          ^lt.referent nil)
-->
   (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*ground-referent*merge*literal
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name ground-referent
          ^constraints.structure-type DP)
   (<op2> ^name merge 
          ^assigner <ass>)
   (<ass> ^structure-type DP
          ^lt.referent-type literal-lti)
-->
   (<s> ^operator <op1> -) # <op2>)  JEL 
}

sp {comprehension*compare*ground-referent*merge*not
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name ground-referent
          ^constraints.structure-type DP)
   (<op2> ^name merge 
          ^assigner <ass>)
   -(<ass> ^structure-type DP
          ^lt.referent nil)
   -(<ass> ^structure-type DP
           ^lt.referent-type literal-lti)
-->
   (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*ground-referent*process-semantics
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name ground-referent)
   (<op2> ^name << ground-new-constraint process-semantics >>)
-->
   (<s> ^operator <op1> > <op2>)
}

sp {comprehension*elaborate*ground-referent*count-constraints*0
   (state <s> ^name comprehension
              ^operator <op1> +)
   (<op1> ^name ground-referent
          ^constraints <con>)
   (<con> -^constraint)
-->
   (<op1> ^constraint-count 0)
}

sp {comprehension*elaborate*ground-referent*count-constraints*1
   (state <s> ^name comprehension
              ^operator <op1> +)
   (<op1> ^name ground-referent
          ^constraints <con>)
   (<con> ^constraint <c1> 
         -^constraint <> <c1>)
-->
   (<op1> ^constraint-count 1)
}

sp {comprehension*elaborate*ground-referent*count-constraints*2
   (state <s> ^name comprehension
              ^operator <op1> +)
   (<op1> ^name ground-referent
          ^constraints <con>)
   (<con> ^constraint <c1> { > <c1> <c2> }
         -^constraint { <> <c1> <> <c2> })
-->
   (<op1> ^constraint-count 2)
}

sp {comprehension*elaborate*ground-referent*count-constraints*3
   (state <s> ^name comprehension
              ^operator <op1> +)
   (<op1> ^name ground-referent
          ^constraints <con>)
   (<con> ^constraint <c1> { > <c1> <c2> } { > <c2> > <c1> <c3> }
         -^constraint { <> <c1> <> <c2> <> <c3> })
-->
   (<op1> ^constraint-count 3)
}

sp {comprehension*elaborate*ground-referent*count-constraints*4
   (state <s> ^name comprehension
              ^operator <op1> +)
   (<op1> ^name ground-referent
          ^constraints <con>)
   (<con> ^constraint <c1> { > <c1> <c2> } { > <c2> > <c1> <c3> }  { > <c2> > <c1> > <c3> <c4> }
         -^constraint { <> <c1> <> <c2> <> <c3> <> <c4> })
-->
   (<op1> ^constraint-count 4)
}


sp {comprehension*elaborate*ground-referent*count-constraints*5
   (state <s> ^name comprehension
              ^operator <op1> +)
   (<op1> ^name ground-referent
          ^constraints <con>)
   (<con> ^constraint <c1> { > <c1> <c2> } { > <c2> > <c1> <c3> }  { > <c2> > <c1> > <c3> <c4> } { > <c2> > <c1> > <c3> > <c4> <c5> }
         -^constraint { <> <c1> <> <c2> <> <c3> <> <c4>  <> <c5>})
-->
   (<op1> ^constraint-count 5)
}


sp {comprehension*apply*ground-referent*zero-constraints
   (state <s> ^name comprehension
              ^operator <op1>)
   (<op1> ^name ground-referent
          ^constraint-count 0
          ^parameter <p>
          ^ << double-constraints constraints >> <c>)
  -(<p> ^lt.specifier)
  -(<p> ^lt.demonstrative)
-->   
      (<c> ^failed-grounding <p>
        ^ground-tested <p>)
   (<p> ^failed-constraint <c>)
   (write (crlf) |No constraints - Error - Assume nothing passes.|)
   (interrupt)
}


