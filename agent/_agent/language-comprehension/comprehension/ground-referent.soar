sp {comprehension*propose*ground-referent
  # :interrupt
   (state <s> ^name comprehension
              ^segment.last-merge <lm>)
   (<lm> ^assigner.parent-receiver <a1>
         ^receiver <r1>)
   (<a1> ^structure-type DP
        -^head.lt.referent nil
        -^head.lt.referent-type literal
        -^head.head.lt.referent nil
        -^head.head.lt.referent-type literal
        -^ground-tested <r1>)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name ground-referent
         ^constraints <a1>
         ^parameter <r1>)
}

sp {comprehension*propose*ground-referent*push*head
   (state <s> ^name comprehension
              ^segment.last-merge <lm>)
   (<lm> ^assigner.parent-receiver <a1>
         ^receiver <r1>)
   (<r1> ^structure-type { <st> << THIS THAT DP >> }
        -^ground-tested <head>)
   (<a1> ^head <head>
        -^ground-tested <head>
        -^head.lt.referent nil
        -^head.lt.referent-type literal
        -^head.head.lt.referent nil
        -^head.head.lt.referent-type literal)
   (<head> ^structure-type <st>
          -^ground-tested <head>)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name ground-referent
         ^constraints <head>
         ^parameter <head>)
}

sp {comprehension*propose*ground-referent*push*complement
   (state <s> ^name comprehension
              ^segment.last-merge <lm>)
   (<lm> ^assigner.parent-receiver <a1>
         ^receiver <r1>)
   (<r1> ^structure-type { <st> << THIS THAT DP >> }
        -^ground-tested <head>)
   (<a1> ^complement <head>
        -^ground-tested <head>
        -^complement.lt.referent nil
        -^complement.lt.referent-type literal
        -^complement.head.lt.referent nil
        -^complement.head.lt.referent-type literal)
   (<head> ^structure-type <st>
          -^ground-tested <head>)
-->
   (<s> ^operator <op> + =, >)
   (<op> ^name ground-referent
         ^constraints <head>
         ^parameter <head>)
}
sp {comprehension*compare*ground-referent
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name ground-referent)
   (<op2> ^name process-phrase-end)
-->
   (<s> ^operator <op1> > <op2>)
}

# Avoid ground reference if referent nil will occur in future merge!
sp {comprehension*compare*ground-referent*merge
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name ground-referent
          ^constraints.structure-type DP)
   (<op2> ^name merge 
          ^assigner <ass>)
   (<ass> ^structure-type DP
          ^lt.referent nil)
-->
   (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*ground-referent*merge*literal
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name ground-referent
          ^constraints.structure-type DP)
   (<op2> ^name merge 
          ^assigner <ass>)
   (<ass> ^structure-type DP
          ^lt.referent-type literal)
-->
   (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*ground-referent*merge*not
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name ground-referent
          ^constraints.structure-type DP)
   (<op2> ^name merge 
          ^assigner <ass>)
   -(<ass> ^structure-type DP
          ^lt.referent nil)
   -(<ass> ^structure-type DP
          ^lt.referent-type literal)
-->
   (<s> ^operator <op1> > <op2>)
}

sp {apply*ground-referent*by-focus
   (state <s> ^operator <op>
              ^segment.last-merge <lm>)
   (<lm> ^assigner.parent-receiver <a1>
         ^receiver <r1>)
   (<op> ^name ground-referent
         ^noun <noun>)
   (<a1> ^head <sub>)
   (<r1> ^lt.preset-semantic-structure <pss>)
   (<pss> ^semantic-structure << agent >>
          ^referent <sg>)
-->
   (write (crlf) |Lexical item grounded by: | <sg>)
   (<sub> ^ground-tested <r1>
          ^referent <sg>)
}

