sp {comprehension*elaborate*possible-merge
   (state <s> ^name comprehension
              ^segment <seg>)
   (<seg> ^not-merged-receiver <receiver>
          ^not-merged-assigner <assigner>)
   (<assigner> ^structure-type <stype>
               ^lt <lt>
              -^lt.lexical-item-spelling)
   (<receiver> ^structure-type <stype>)
  -(<assigner> ^parent-receiver <receiver>) # Cannot fulfill itself
 -{(<assigner> ^lt.after <after>
               ^parent-receiver <pr>)           # enforce after
   (<seg> ^not-merged-assigner <nma>)
   (<nma> ^parent-receiver <pr>
          ^lt <after>)}
 -{(<receiver> ^decision-count > <dl-dc>)   # enforce before
   (<assigner> ^lt.relative-position before
               ^decision-count <dl-dc>)}
 -{(<receiver> ^decision-count < <dl-dc2>)   # enforce after on DC
   (<assigner> ^lt.relative-position after
               ^decision-count <dl-dc2>)}
-{(<assigner> ^lt.directional <x>)      # Do not match prepositions that have different directional values - for example onto is directional, but the PP in a determiner is not directional
  (<receiver> ^lt.directional <> <x>)}
#-{(<seg> ^not-merged-assigner.lt <ass2>)
#  (<ass2> ^required true
#          ^before <lt>)}
-->
   (<s> ^possible-merge <pm>)
   (<pm> ^receiver <receiver>
         ^assigner <assigner>
         ^type normal)
   (write (crlf) |Possible Merge: | <stype>)
}

sp {comprehension*elaborate*possible-merge*lexical-item*match*required
   (state <s> ^name comprehension
              ^segment <seg>)
   (<seg> ^not-merged-receiver <receiver>
          ^not-merged-assigner <assigner>)
   (<assigner> ^structure-type <stype>
               ^lt.lexical-item-spelling <lex-item-spell>)
   (<receiver> ^structure-type <stype>
               ^lt.spelling <lex-item-spell>)
  -(<assigner> ^parent-receiver <receiver>) # Cannot fulfill itself
 -{(<assigner> ^parent-receiver <parent>)
   (<receiver> ^ << DP VP PP CP CONJP >> <parent>)}
 -{(<assigner> ^lt.after <after>
               ^parent-receiver <pr>)           # enforce after
   (<seg> ^not-merged-assigner <nma>)
   (<nma> ^parent-receiver <pr>
          ^lt <after>)}
 -{(<receiver> ^decision-count > <dl-dc>)   # enforce before
   (<assigner> ^lt.relative-position before
               ^decision-count <dl-dc>)}
 -{(<receiver> ^decision-count < <dl-dc>)   # enforce after on DC
   (<assigner> ^lt.relative-position after
               ^decision-count <dl-dc>)}
-{(<assigner> ^lt.directional <x>)      # Do not match prepositions that have different directional values - for example onto is directional, but the PP in a determiner is not directional
  (<receiver> ^lt.directional <> <x>)}
-->
   (<s> ^possible-merge <pm>)
   (<pm> ^receiver <receiver>
         ^assigner <assigner>
         ^type lexical)
   (write (crlf) |Propose lexical-item match merging: | <lex-item-spell>)
}
#####
sp {comprehension*elaborate*possible-merge*unknown
   (state <s> ^name comprehension
              ^segment <seg>)
   (<seg> ^not-merged-receiver <receiver>
          ^not-merged-assigner <assigner>)
   (<assigner> ^structure-type U
              -^lt.lexical-item-spelling)
   (<receiver> -^structure-type)
  -(<assigner> ^parent-receiver <receiver>) # Cannot fulfill itself
 -{(<assigner> ^lt.after <after>
               ^parent-receiver <pr>)           # enforce after
   (<seg> ^not-merged-assigner <nma>)
   (<nma> ^parent-receiver <pr>
          ^lt <after>)}
 -{(<receiver> ^decision-count > <dl-dc>)   # enforce before
   (<assigner> ^lt.relative-position before
               ^decision-count <dl-dc>)}
 -{(<receiver> ^decision-count < <dl-dc2>)   # enforce after on DC
   (<assigner> ^lt.relative-position after
               ^decision-count <dl-dc2>)}
-->
   (<s> ^possible-merge <pm>)
   (<pm> ^receiver <receiver>
         ^assigner <assigner>
         ^type normal)
   (write (crlf) |Possible Merge: UNKNOWN|)
}

sp {comprehension*elaborate*possible-merge*lexical-item*match*required*unknown
   (state <s> ^name comprehension
              ^segment <seg>)
   (<seg> ^not-merged-receiver <receiver>
          ^not-merged-assigner <assigner>)
   (<assigner> ^structure-type U
               ^lt.lexical-item-spelling <lex-item-spell>)
   (<receiver> -^structure-type
               ^lt.spelling <lex-item-spell>)
  -(<assigner> ^parent-receiver <receiver>) # Cannot fulfill itself
 -{(<assigner> ^parent-receiver <parent>)
   (<receiver> ^ << DP VP PP CP CONJP >> <parent>)}
 -{(<assigner> ^lt.after <after>
               ^parent-receiver <pr>)           # enforce after
   (<seg> ^not-merged-assigner <nma>)
   (<nma> ^parent-receiver <pr>
          ^lt <after>)}
 -{(<receiver> ^decision-count > <dl-dc>)   # enforce before
   (<assigner> ^lt.relative-position before
               ^decision-count <dl-dc>)}
 -{(<receiver> ^decision-count < <dl-dc>)   # enforce after on DC
   (<assigner> ^lt.relative-position after
               ^decision-count <dl-dc>)}
-->
   (<s> ^possible-merge <pm>)
   (<pm> ^receiver <receiver>
         ^assigner <assigner>
         ^type lexical)
   (write (crlf) |Propose lexical-item match merging: | <lex-item-spell>)
}
#####

sp {comprehension*propose*merge
   (state <s> ^name comprehension
              ^possible-merge <pm>)
   (<pm> ^receiver <receiver>
         ^assigner <assigner>
         ^type <type>) 
-->
   (<s> ^operator <op> +)
   (<op> ^name merge
         ^receiver <receiver>
         ^assigner <assigner>
         ^type <type>)
   (write (crlf) |Propose Merging: | <receiver> | and | <assigner>)
}

###Selection - rejects

### Reject if there is a before that hasn't merged
##   and that before isn't waiting on the same possible merge
sp {comprehension*reject*possible-merge
   (state <s> ^name comprehension
              ^operator <op1> +
              ^segment.not-merged-assigner <nma>)
   (<op1> ^name merge
          ^receiver <receiver>
          ^assigner <assigner>)
   (<assigner> ^lt <lt>)
   (<nma> ^lt <ass2>)
   (<ass2> ^required true
           ^before <lt>)
 -{(<s> ^possible-merge <pm>)
   (<pm> ^receiver <receiver>
         ^assigner <> <assigner>)}
-->
   (<s> ^operator <op1> -)
   (write (crlf) |Reject: | <op1> | because a before unsatisfied assigner is required.|)
}

sp {comprehension*reject*merge*for-failed-grounding
  #:interrupt
   (state <s> ^name comprehension
              ^operator <op1> +
              ^segment <seg>)
   (<seg> ^failed-grounding <fg>)
   (<op1> ^name merge
          ^receiver <ai>
          ^assigner <ur>)
   (<fg> ^structure-type <pos>
         ^receiver-word <rw>
         ^relation <sr>
         ^lost-grounding <lg>)
   (<ai> ^structure-type <pos>
         ^relation <sr>)
   (<ur> ^parent-receiver.referent <lg>)
-->
   (<s> ^operator <op1> -)
}


sp {comprehension*reject*merge*left-noun
  #:interrupt
   (state <s> ^name comprehension
              ^operator <op1> +)
   (<op1> ^name merge
          ^assigner.parent-receiver.head.lt.spelling << left-noun right-noun >>
         -^receiver.lt.spelling of)
-->
   (<s> ^operator <op1> -)
}

# prefer lexical merges
sp {comprehension*compare*merge*prefer-lexical
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name merge 
          ^type normal)
   (<op2> ^name merge
          ^type lexical) 
-->
   (<s> ^operator <op1> < <op2>)
}

# avoid merging until comprehend-word is complete
sp {comprehension*compare*merge*comprehend-word
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name merge)
   (<op2> ^name comprehend-word) 
-->
   (<s> ^operator <op1> < <op2>)
}

sp {comprehension*compare*merge*comprehend-word*process-missing-assigner
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name merge)
   (<op2> ^name << failed-comprehension process-missing-assigner >>)
-->
   (<s> ^operator <op1> > <op2>)}
   
   
sp {comprehension*compare*merge*terminate*next-word
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name merge)
   (<op2> ^name << next-word next-retrieved-stack termination-processing >> )
-->
   (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*indifferent-different-receiver
   (state <s> ^name comprehension
              ^operator <op1> +
                        <op2> +)
   (<op1> ^name merge
          ^receiver <receiver>)
   (<op2> ^name merge
          ^receiver <> <receiver>)
-->
   (<s> ^operator <op1> = <op2>)
}

sp {comprehension*compare*merge*avoid-terminator
   (state <s> ^name comprehension
              ^operator <op1> +
              ^operator <op2> +)
   (<op1> ^name merge
          ^assigner.syntactic-type terminator)
   (<op2> ^name merge
         -^assigner.syntactic-type terminator)
-->
   (<s> ^operator <op1> < <op2>)
}

## Prefer merging a PP that is directional (to, into, onto) to the Verb.
##  Note: "to the right" is converted to right-of (instead of to).
sp {comprehension*compare*merge*prefer*directional-verb
  #:interrupt
   (state <s> ^name comprehension
              ^operator <op1> +
              ^operator <op2> +)
   (<op1> ^name merge
          ^receiver <r1>
          ^assigner.parent-receiver.structure-type << V VP >>)
   (<r1> ^structure-type PP
         ^lt.directional true)
   (<op2> ^name merge
          ^receiver <r1>
         -^assigner.parent-receiver.structure-type << V VP >>)
-->
   (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*directional-verb-convert
  #:interrupt
   (state <s> ^name comprehension
              ^operator <op1> +
              ^operator <op2> +)
   (<op1> ^name merge
          ^receiver <r1>
          ^assigner.parent-receiver.structure-type << UV V VP >>)
   (<r1> ^structure-type PP
         ^lt.directional true)
   (<op2> ^name merge
          ^receiver <r1>
         -^assigner.parent-receiver.structure-type << V VP >>)
-->
   (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*first*same-receiver
   (state <s> ^name comprehension
              ^operator <op1> +
              ^operator <op2> +)
   (<op1> ^name merge
          ^assigner <ass1>
          ^receiver <rec>)
   (<ass1> ^parent-receiver <ps>
           ^lt.before <ltass2>)
   (<op2> ^name merge
          ^assigner <ass2>
          ^receiver <rec>)
   (<ass2> ^parent-receiver <ps>
           ^lt <ltass2>
           ^structure-type <bt>)
-->
   (<s> ^operator <op1> > <op2>)
}


sp {comprehension*compare*merge*prefer*most-recent*same-parent-receiver
   (state <s> ^name comprehension
              ^operator <op1> +
              ^operator <op2> +)
   (<op1> ^name merge
          ^assigner <ass1>
          ^receiver <rec>)
   (<ass1> ^parent-receiver <ps>
           ^lt.before <ltass2>)
   (<op2> ^name merge
          ^assigner <ass2>
          ^receiver <> <rec>)
   (<ass2> ^parent-receiver <ps>
           ^lt <ltass2>
           ^structure-type <bt>)
-->
   (<s> ^operator <op1> > <op2>)
}


sp {comprehension*compare*merge*prefer*most-recent*same-parent-receiver2
   (state <s> ^name comprehension
              ^operator <op1> +
              ^operator <op2> +)
   (<op1> ^name merge
          ^assigner <ass1>
          ^receiver <rec>)
   (<ass1> ^parent-receiver <ps>
           ^lt <ltass1>)
   (<op2> ^name merge
          ^assigner <ass2>
          ^receiver <> <rec>)
   (<ass2> ^parent-receiver <ps>
           ^structure-type <bt>
           ^lt.after <ltass1>)
-->
   (<s> ^operator <op1> > <op2>)
}

sp {comprehension*compare*merge*prefer*most-recent*not-pp2
   (state <s> ^name comprehension
              ^operator <op1> +
              ^operator <op2> +)
   (<op1> ^name merge
          ^assigner <ass1>
          ^receiver <rec>)
   (<ass1> ^decision-count <dc>
           ^lt <lt1>)
   (<lt1> -^before <ltass2>)
   (<op2> ^name merge
          ^assigner <ass2>
          ^receiver <rec>)
   (<ass2> ^decision-count > <dc>
           ^lt <ltass2>)
  -(<rec> ^structure-type PP)
-->
   (<s> ^operator <op1> -)
}
sp {comprehension*compare*merge*prefer*most-recent*not-pp*before
   (state <s> ^name comprehension
              ^operator <op1> +
              ^operator <op2> +)
   (<op1> ^name merge
          ^assigner <ass1>
          ^receiver <rec>)
   (<ass1> ^decision-count <dc>
           ^parent-receiver <pr>
           ^lt <lt1>)
   (<lt1> ^before <ltass2>
          ^required true)
   (<op2> ^name merge
          ^assigner <ass2>
          ^receiver <rec>
          ^parent-receiver <pr>)
   (<ass2> ^decision-count <dc>
           ^lt <ltass2>)
   (<ltass2> ^optional true)
  -(<rec> ^structure-type PP)
-->
   (<s> ^operator <op2> -)
}

sp {comprehension*compare*merge*prefer*most-recent*not-pp*before2
   (state <s> ^name comprehension
              ^operator <op1> +
              ^operator <op2> +)
   (<op1> ^name merge
          ^assigner <ass1>
          ^receiver <rec>)
   (<ass1> ^decision-count <dc>
           ^lt <lt1>
           ^parent-receiver <pr>)
   (<lt1> ^before <ltass2>)
   (<op2> ^name merge
          ^assigner <ass2>
          ^receiver <rec>)
   (<ass2> ^decision-count > <dc>
           ^lt <ltass2>
           ^parent-receiver <pr>)
  -(<rec> ^structure-type PP)
-->
   (<s> ^operator <op2> -)
}

sp {comprehension*compare*merge*prefer*most-recent*attachment-immediate
   (state <s> ^name comprehension
              ^operator <op1> +
              ^operator { <> <op1> <op2> } +)
   (<op1> ^name merge
          ^assigner <ass1>
          ^receiver <rec>)
   (<ass1> ^decision-count <dc>)
   (<rec> ^lt.attachment immediate)
   (<op2> ^name merge
          ^assigner <ass2>
          ^receiver <rec>)
  (<ass2> ^decision-count > <dc>)
-->
   (<s> ^operator <op1> < <op2>)
}
