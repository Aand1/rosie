# TODO: report an action as performed when it has finished

sp {propose*write*action*status*top-state
   (state <s> ^superstate <ss>
          ^impasse no-change
          ^attribute state)
   (<ss> ^superstate-indexed-action <act>
     ^name action
     ^superstate.operator.name action
         ^top-state.interaction.status <stat>
         ^lexical-information <lex>)
   (<act> ^applied yes)
-->
   (<stat> ^performed <performed>)
   (<performed> ^action-event <ae>)
   (<ae> ^type <lex>)
}

sp {mark*indexed-operator*applied
   (state <s> ^name action
          ^superstate-indexed-action <map-op>
          ^operator <op>)
   (<op> ^action-type primitive)
-->
   (<map-op> ^applied yes)
}

# TODO: When a subaction is executed inside a composite action,
# add it to the smem rep for the composite action

sp {augment-problem-space*semantic-memory*superoperator
   (state <s> ^name action
          ^indexed-action <iop>
          ^top-state.interaction.stack.segment.next.purpose <super-action>
          ^smem.command <scomm>)
   (<super-action> ^type action-command
           ^parameters.indexable.result._metadata.map-id <map-id>)
   (<map-id> ^action-space <p>)
   (<iop> ^_metadata.map-id {<nmap> <> <map-id>}
      ^action-type composite
      ^name <op-name>
      -^applied yes)
   (<nmap> ^procedural <procedural>)
-->
   (<p> ^_operator <procedural>)
   (<scomm> ^store <p>)
}

# TODO: propose/augment a put-down operator when there is an action-command
#   with a specified relation
sp {augment*relationship
   (state <s> ^name action
          ^superstate-indexed-action <iop>
          ^operator <op> +)
   (<iop> ^<arg> <val>)
   (<val> ^relation <rel>
      ^<arg2> <obj>)
   (<op> ^<arg> <nval>
     ^name op_put-down-object-location)
   (<nval> ^<arg2> <obj>)
-->
   (<nval> ^relation <rel>)
}

sp {elaborate*put-down*operator
   (state <s> ^desired <d>
          ^operator <op> +
          ^in-focus.<id> <lobj>) 
   (<op> ^name op_put-down-object-location
     ^argument2 <arg>)
   (<arg> ^argument <lobj>)
   (<d> ^track-relation <tr>
        ^in-focus.<id> <dlobj>)
   (<tr> ^p2 <dlobj>
     ^relation <rel>)
-->
   (<arg> ^relation <rel>)
}

# TODO: propose a wait operator when an action-command is present
#   with a termination condition
sp {mark*operators*match*op_wait
   (state <s> ^name action
             ^operator <op> +
         ^superstate-indexed-action <ia>
         ^action-matches.match-set <ms>)
   (<ms> ^operator <op>)
   (<ia> ^{<arg> <> name} <val>)
   (<op> ^name op_wait)
-->
   (<ms> ^matched <arg>)
}

sp {elaborate*op_wait*operator
   (state <s> ^desired <d>
          ^operator <op> +
          ^in-focus.<id> <lobj>) 
   (<op> ^name op_wait)
   (<d> ^achieve-state <astate>
    ^in-focus.<id> <dobj>)
   (<astate> ^p1 <dobj>
         ^state cooked)
-->
   (<op> ^argument1 <arg>)
   (<arg> ^argument <lobj>
      ^state cooked)
}

# TODO: In the case of a tie due to multiple arguments, 
#       Break ties using preference knowledge

   
# TODO: boost activations of objects in action-commands
#       Bias objects based on their activation values
sp {boost*activations*objects*actions*argument*level1
   (state <s> ^name action
   	      ^operator <op>
	      ^smem.command <scomm>)
   (<op> ^action-type << primitive composite >>
   	 ^<arg> <obj1>)
#    -^<arg> {<obj2> <> <obj1>})	# AM: Fix: so a tied argument wont get stored
   (<obj1> ^id <obj-id>
           ^predicates <obj-rep>)
-->
   (<scomm> ^store <obj-rep>)
}

sp {boost*activations*objects*actions*argument*level2
   (state <s> ^name action
   	        ^operator <op>
	        ^smem.command <scomm>)
   (<op> ^action-type << primitive composite >>
   	   ^<arg1>.<arg2> <val>)
#    -^<arg1>.<arg2> {<val2> <> <val>})	# AM: Fix: so a tied argument wont get stored
   (<val> ^id <obj-id>
          ^predicates <obj-rep>)
-->
   (<scomm> ^store <obj-rep>)
}