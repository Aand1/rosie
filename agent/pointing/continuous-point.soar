# Creates the substate; doesn't specify which object must be tracked...
sp {propose*continuous-point
   (state <s> ^name pointer
              ^io.input-link.objects.object <object>)
   (<object> ^visual-prop <v>)
   (<v> ^category color)
-->
   (<s> ^operator <o> + =)
   (<o> ^name continuous-point
        ^object <object>)
}

sp {continuous-point*elaborate*tracked-object
   (state <s> ^name continuous-point 
	          ^superstate.operator.object <obj>)
-->
   (<s> ^tracked-object <obj>)
}

# When x, y of pose get updated, this re-fires
sp {continuous-point*propose*point
   (state <s> ^name continuous-point
              ^tracked-object <obj>
              ^io.input-link <in>)
   (<obj> ^id <id>
          ^pose <pose>)
   (<pose> ^x <x>
           ^y <y>)
-->
   (<s> ^operator <o> +)
   (<o> ^name point
        ^actions.move <point>
        ^object <obj>)
   (<point> ^id <id>
	    ^pose <p>)
   # This is a real hack... stops the arm from being directly above the object
   # and blocking it from view.
   (<p> ^x (- <x> 0.08)
        ^y (- <y> 0.08)
        ^z 0.1)
}

sp {continuous-point*apply*point*elaborate*last-location
   (state <s> ^name continuous-point
              ^operator.name point
              ^superstate <ss>
              ^tracked-object.pose <pose>)
   (<pose> ^x <x>
           ^y <y>)
   -->
   (<ss> ^last-location <last>)
   (<last> ^x <x>
           ^y <y>)
}

sp {continuous-point*apply*point*remove*last-location*x
   (state <s> ^name continuous-point
              ^operator.name point
              ^superstate <ss>
              ^tracked-object.pose <pose>)
   (<pose> ^x <x>)
   (<ss> ^last-location <last>)
   (<last> ^x <> <x>)
   -->
   (<ss> ^last-location <last> -)
}

sp {continuous-point*apply*point*remove*last-location*y
   (state <s> ^name continuous-point
              ^operator.name point
              ^superstate <ss>
              ^tracked-object.pose <pose>)
   (<pose> ^y <y>)
   (<ss> ^last-location <last>)
   (<last> ^y <> <y>)
   -->
   (<ss> ^last-location <last> -)
}